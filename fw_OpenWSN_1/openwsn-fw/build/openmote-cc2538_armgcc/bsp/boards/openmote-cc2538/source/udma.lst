   1              		.cpu cortex-m3
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 6
   9              		.eabi_attribute 34, 1
  10              		.eabi_attribute 18, 4
  11              		.file	"udma.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.align	1
  16              		.global	uDMAEnable
  17              		.syntax unified
  18              		.thumb
  19              		.thumb_func
  20              		.fpu softvfp
  22              	uDMAEnable:
  23              	.LFB0:
  24              		.file 1 "build\\openmote-cc2538_armgcc\\bsp\\boards\\openmote-cc2538\\source\\udma.c"
   1:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** /******************************************************************************
   2:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** *  Filename:       udma.c
   3:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** *  Revised:        $Date: 2013-03-20 14:47:53 +0100 (Wed, 20 Mar 2013) $
   4:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** *  Revision:       $Revision: 9489 $
   5:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** *
   6:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** *  Description:    Driver for the micro-DMA controller.
   7:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** *
   8:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** *  Copyright (C) 2012 Texas Instruments Incorporated - http://www.ti.com/
   9:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** *
  10:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** *
  11:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** *  Redistribution and use in source and binary forms, with or without
  12:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** *  modification, are permitted provided that the following conditions
  13:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** *  are met:
  14:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** *
  15:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** *    Redistributions of source code must retain the above copyright
  16:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** *    notice, this list of conditions and the following disclaimer.
  17:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** *
  18:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** *    Redistributions in binary form must reproduce the above copyright
  19:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** *    notice, this list of conditions and the following disclaimer in the
  20:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** *    documentation and/or other materials provided with the distribution.
  21:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** *
  22:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** *    Neither the name of Texas Instruments Incorporated nor the names of
  23:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** *    its contributors may be used to endorse or promote products derived
  24:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** *    from this software without specific prior written permission.
  25:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** *
  26:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  27:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  28:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  29:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  30:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  31:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  32:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  33:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  34:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  35:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  36:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  37:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** *
  38:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** ******************************************************************************/
  39:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
  40:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //*****************************************************************************
  41:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //
  42:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \addtogroup udma_api
  43:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! @{
  44:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //
  45:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //*****************************************************************************
  46:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
  47:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** #include <headers/hw_sys_ctrl.h>
  48:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** #include <headers/hw_udma.h>
  49:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** #include <headers/hw_udmachctl.h>
  50:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** #include "debug.h"
  51:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** #include "interrupt.h"
  52:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** #include "udma.h"
  53:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
  54:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //*****************************************************************************
  55:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //
  56:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! Enables the uDMA controller for use
  57:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
  58:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! This function enables the uDMA controller.  The uDMA controller must be
  59:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! enabled before it can be configured and used.
  60:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
  61:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \return None
  62:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //
  63:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //*****************************************************************************
  64:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** void
  65:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** uDMAEnable(void)
  66:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** {
  25              		.loc 1 66 0
  26              		.cfi_startproc
  27              		@ args = 0, pretend = 0, frame = 0
  28              		@ frame_needed = 1, uses_anonymous_args = 0
  29              		@ link register save eliminated.
  30 0000 80B4     		push	{r7}
  31              		.cfi_def_cfa_offset 4
  32              		.cfi_offset 7, -4
  33 0002 00AF     		add	r7, sp, #0
  34              		.cfi_def_cfa_register 7
  67:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
  68:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Set the master enable bit in the config register.
  69:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
  70:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     HWREG(UDMA_CFG) = UDMA_CFG_MASTEN;
  35              		.loc 1 70 0
  36 0004 034B     		ldr	r3, .L2
  37 0006 0122     		movs	r2, #1
  38 0008 1A60     		str	r2, [r3]
  71:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** }
  39              		.loc 1 71 0
  40 000a 00BF     		nop
  41 000c BD46     		mov	sp, r7
  42              		.cfi_def_cfa_register 13
  43              		@ sp needed
  44 000e 80BC     		pop	{r7}
  45              		.cfi_restore 7
  46              		.cfi_def_cfa_offset 0
  47 0010 7047     		bx	lr
  48              	.L3:
  49 0012 00BF     		.align	2
  50              	.L2:
  51 0014 04F00F40 		.word	1074786308
  52              		.cfi_endproc
  53              	.LFE0:
  55              		.align	1
  56              		.global	uDMADisable
  57              		.syntax unified
  58              		.thumb
  59              		.thumb_func
  60              		.fpu softvfp
  62              	uDMADisable:
  63              	.LFB1:
  72:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
  73:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //*****************************************************************************
  74:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //
  75:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! Disables the uDMA controller for use
  76:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
  77:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! This function disables the uDMA controller.  Once disabled, the uDMA
  78:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! controller will not operate until re-enabled with uDMAEnable().
  79:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
  80:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \return None
  81:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //
  82:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //*****************************************************************************
  83:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** void
  84:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** uDMADisable(void)
  85:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** {
  64              		.loc 1 85 0
  65              		.cfi_startproc
  66              		@ args = 0, pretend = 0, frame = 0
  67              		@ frame_needed = 1, uses_anonymous_args = 0
  68              		@ link register save eliminated.
  69 0018 80B4     		push	{r7}
  70              		.cfi_def_cfa_offset 4
  71              		.cfi_offset 7, -4
  72 001a 00AF     		add	r7, sp, #0
  73              		.cfi_def_cfa_register 7
  86:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
  87:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Clear the master enable bit in the config register.
  88:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
  89:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     HWREG(UDMA_CFG) = 0;
  74              		.loc 1 89 0
  75 001c 034B     		ldr	r3, .L5
  76 001e 0022     		movs	r2, #0
  77 0020 1A60     		str	r2, [r3]
  90:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** }
  78              		.loc 1 90 0
  79 0022 00BF     		nop
  80 0024 BD46     		mov	sp, r7
  81              		.cfi_def_cfa_register 13
  82              		@ sp needed
  83 0026 80BC     		pop	{r7}
  84              		.cfi_restore 7
  85              		.cfi_def_cfa_offset 0
  86 0028 7047     		bx	lr
  87              	.L6:
  88 002a 00BF     		.align	2
  89              	.L5:
  90 002c 04F00F40 		.word	1074786308
  91              		.cfi_endproc
  92              	.LFE1:
  94              		.align	1
  95              		.global	uDMAErrorStatusGet
  96              		.syntax unified
  97              		.thumb
  98              		.thumb_func
  99              		.fpu softvfp
 101              	uDMAErrorStatusGet:
 102              	.LFB2:
  91:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
  92:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //*****************************************************************************
  93:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //
  94:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! Gets the uDMA error status
  95:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
  96:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! This function returns the uDMA error status.  It should be called from
  97:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! within the uDMA error interrupt handler to determine if a uDMA error
  98:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! occurred.
  99:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
 100:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \return Returns non-zero if a uDMA error is pending.
 101:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //
 102:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //*****************************************************************************
 103:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** uint32_t
 104:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** uDMAErrorStatusGet(void)
 105:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** {
 103              		.loc 1 105 0
 104              		.cfi_startproc
 105              		@ args = 0, pretend = 0, frame = 0
 106              		@ frame_needed = 1, uses_anonymous_args = 0
 107              		@ link register save eliminated.
 108 0030 80B4     		push	{r7}
 109              		.cfi_def_cfa_offset 4
 110              		.cfi_offset 7, -4
 111 0032 00AF     		add	r7, sp, #0
 112              		.cfi_def_cfa_register 7
 106:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 107:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Return the uDMA error status.
 108:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 109:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     return(HWREG(UDMA_ERRCLR));
 113              		.loc 1 109 0
 114 0034 024B     		ldr	r3, .L9
 115 0036 1B68     		ldr	r3, [r3]
 110:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** }
 116              		.loc 1 110 0
 117 0038 1846     		mov	r0, r3
 118 003a BD46     		mov	sp, r7
 119              		.cfi_def_cfa_register 13
 120              		@ sp needed
 121 003c 80BC     		pop	{r7}
 122              		.cfi_restore 7
 123              		.cfi_def_cfa_offset 0
 124 003e 7047     		bx	lr
 125              	.L10:
 126              		.align	2
 127              	.L9:
 128 0040 4CF00F40 		.word	1074786380
 129              		.cfi_endproc
 130              	.LFE2:
 132              		.align	1
 133              		.global	uDMAErrorStatusClear
 134              		.syntax unified
 135              		.thumb
 136              		.thumb_func
 137              		.fpu softvfp
 139              	uDMAErrorStatusClear:
 140              	.LFB3:
 111:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
 112:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //*****************************************************************************
 113:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //
 114:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! Clears the uDMA error interrupt
 115:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
 116:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! This function clears a pending uDMA error interrupt.  It should be called
 117:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! from within the uDMA error interrupt handler to clear the interrupt.
 118:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
 119:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \return None
 120:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //
 121:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //*****************************************************************************
 122:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** void
 123:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** uDMAErrorStatusClear(void)
 124:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** {
 141              		.loc 1 124 0
 142              		.cfi_startproc
 143              		@ args = 0, pretend = 0, frame = 0
 144              		@ frame_needed = 1, uses_anonymous_args = 0
 145              		@ link register save eliminated.
 146 0044 80B4     		push	{r7}
 147              		.cfi_def_cfa_offset 4
 148              		.cfi_offset 7, -4
 149 0046 00AF     		add	r7, sp, #0
 150              		.cfi_def_cfa_register 7
 125:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 126:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Clear the uDMA error interrupt.
 127:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 128:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     HWREG(UDMA_ERRCLR) = 1;
 151              		.loc 1 128 0
 152 0048 034B     		ldr	r3, .L12
 153 004a 0122     		movs	r2, #1
 154 004c 1A60     		str	r2, [r3]
 129:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** }
 155              		.loc 1 129 0
 156 004e 00BF     		nop
 157 0050 BD46     		mov	sp, r7
 158              		.cfi_def_cfa_register 13
 159              		@ sp needed
 160 0052 80BC     		pop	{r7}
 161              		.cfi_restore 7
 162              		.cfi_def_cfa_offset 0
 163 0054 7047     		bx	lr
 164              	.L13:
 165 0056 00BF     		.align	2
 166              	.L12:
 167 0058 4CF00F40 		.word	1074786380
 168              		.cfi_endproc
 169              	.LFE3:
 171              		.align	1
 172              		.global	uDMAChannelEnable
 173              		.syntax unified
 174              		.thumb
 175              		.thumb_func
 176              		.fpu softvfp
 178              	uDMAChannelEnable:
 179              	.LFB4:
 130:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
 131:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //*****************************************************************************
 132:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //
 133:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! Enables a uDMA channel for operation
 134:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
 135:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \param ui32ChannelNum is the channel number to enable.
 136:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
 137:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! This function enables a specific uDMA channel for use.  This function must
 138:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! be used to enable a channel before it can be used to perform a uDMA
 139:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! transfer.
 140:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
 141:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! When a uDMA transfer is completed, the channel will be automatically
 142:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! disabled by the uDMA controller.  Therefore, this function should be called
 143:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! prior to starting up any new transfer.
 144:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
 145:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \return None
 146:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //
 147:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //*****************************************************************************
 148:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** void
 149:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** uDMAChannelEnable(uint32_t ui32ChannelNum)
 150:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** {
 180              		.loc 1 150 0
 181              		.cfi_startproc
 182              		@ args = 0, pretend = 0, frame = 8
 183              		@ frame_needed = 1, uses_anonymous_args = 0
 184              		@ link register save eliminated.
 185 005c 80B4     		push	{r7}
 186              		.cfi_def_cfa_offset 4
 187              		.cfi_offset 7, -4
 188 005e 83B0     		sub	sp, sp, #12
 189              		.cfi_def_cfa_offset 16
 190 0060 00AF     		add	r7, sp, #0
 191              		.cfi_def_cfa_register 7
 192 0062 7860     		str	r0, [r7, #4]
 151:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 152:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Check the arguments.
 153:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 154:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     ASSERT((ui32ChannelNum & 0xffff) < 32);
 155:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
 156:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 157:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Set the bit for this channel in the enable set register.
 158:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 159:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     HWREG(UDMA_ENASET) = 1 << (ui32ChannelNum & 0x1f);
 193              		.loc 1 159 0
 194 0064 7B68     		ldr	r3, [r7, #4]
 195 0066 03F01F03 		and	r3, r3, #31
 196 006a 0122     		movs	r2, #1
 197 006c 9A40     		lsls	r2, r2, r3
 198 006e 034B     		ldr	r3, .L15
 199 0070 1A60     		str	r2, [r3]
 160:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** }
 200              		.loc 1 160 0
 201 0072 00BF     		nop
 202 0074 0C37     		adds	r7, r7, #12
 203              		.cfi_def_cfa_offset 4
 204 0076 BD46     		mov	sp, r7
 205              		.cfi_def_cfa_register 13
 206              		@ sp needed
 207 0078 80BC     		pop	{r7}
 208              		.cfi_restore 7
 209              		.cfi_def_cfa_offset 0
 210 007a 7047     		bx	lr
 211              	.L16:
 212              		.align	2
 213              	.L15:
 214 007c 28F00F40 		.word	1074786344
 215              		.cfi_endproc
 216              	.LFE4:
 218              		.align	1
 219              		.global	uDMAChannelDisable
 220              		.syntax unified
 221              		.thumb
 222              		.thumb_func
 223              		.fpu softvfp
 225              	uDMAChannelDisable:
 226              	.LFB5:
 161:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
 162:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //*****************************************************************************
 163:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //
 164:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! Disables a uDMA channel for operation
 165:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
 166:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \param ui32ChannelNum is the channel number to disable.
 167:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
 168:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! This function disables a specific uDMA channel.  Once disabled, a channel
 169:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! will not respond to uDMA transfer requests until re-enabled via
 170:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! uDMAChannelEnable().
 171:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
 172:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \return None
 173:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //
 174:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //*****************************************************************************
 175:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** void
 176:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** uDMAChannelDisable(uint32_t ui32ChannelNum)
 177:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** {
 227              		.loc 1 177 0
 228              		.cfi_startproc
 229              		@ args = 0, pretend = 0, frame = 8
 230              		@ frame_needed = 1, uses_anonymous_args = 0
 231              		@ link register save eliminated.
 232 0080 80B4     		push	{r7}
 233              		.cfi_def_cfa_offset 4
 234              		.cfi_offset 7, -4
 235 0082 83B0     		sub	sp, sp, #12
 236              		.cfi_def_cfa_offset 16
 237 0084 00AF     		add	r7, sp, #0
 238              		.cfi_def_cfa_register 7
 239 0086 7860     		str	r0, [r7, #4]
 178:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 179:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Check the arguments.
 180:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 181:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     ASSERT((ui32ChannelNum & 0xffff) < 32);
 182:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
 183:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 184:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Set the bit for this channel in the enable clear register.
 185:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 186:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     HWREG(UDMA_ENACLR) = 1 << (ui32ChannelNum & 0x1f);
 240              		.loc 1 186 0
 241 0088 7B68     		ldr	r3, [r7, #4]
 242 008a 03F01F03 		and	r3, r3, #31
 243 008e 0122     		movs	r2, #1
 244 0090 9A40     		lsls	r2, r2, r3
 245 0092 034B     		ldr	r3, .L18
 246 0094 1A60     		str	r2, [r3]
 187:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** }
 247              		.loc 1 187 0
 248 0096 00BF     		nop
 249 0098 0C37     		adds	r7, r7, #12
 250              		.cfi_def_cfa_offset 4
 251 009a BD46     		mov	sp, r7
 252              		.cfi_def_cfa_register 13
 253              		@ sp needed
 254 009c 80BC     		pop	{r7}
 255              		.cfi_restore 7
 256              		.cfi_def_cfa_offset 0
 257 009e 7047     		bx	lr
 258              	.L19:
 259              		.align	2
 260              	.L18:
 261 00a0 2CF00F40 		.word	1074786348
 262              		.cfi_endproc
 263              	.LFE5:
 265              		.align	1
 266              		.global	uDMAChannelIsEnabled
 267              		.syntax unified
 268              		.thumb
 269              		.thumb_func
 270              		.fpu softvfp
 272              	uDMAChannelIsEnabled:
 273              	.LFB6:
 188:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
 189:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //*****************************************************************************
 190:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //
 191:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! Checks if a uDMA channel is enabled for operation
 192:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
 193:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \param ui32ChannelNum is the channel number to check.
 194:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
 195:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! This function checks to see if a specific uDMA channel is enabled.  This
 196:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! can be used to check the status of a transfer, since the channel will
 197:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! be automatically disabled at the end of a transfer.
 198:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
 199:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \return Returns \b true if the channel is enabled, \b false if disabled.
 200:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //
 201:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //*****************************************************************************
 202:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** bool
 203:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** uDMAChannelIsEnabled(uint32_t ui32ChannelNum)
 204:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** {
 274              		.loc 1 204 0
 275              		.cfi_startproc
 276              		@ args = 0, pretend = 0, frame = 8
 277              		@ frame_needed = 1, uses_anonymous_args = 0
 278              		@ link register save eliminated.
 279 00a4 80B4     		push	{r7}
 280              		.cfi_def_cfa_offset 4
 281              		.cfi_offset 7, -4
 282 00a6 83B0     		sub	sp, sp, #12
 283              		.cfi_def_cfa_offset 16
 284 00a8 00AF     		add	r7, sp, #0
 285              		.cfi_def_cfa_register 7
 286 00aa 7860     		str	r0, [r7, #4]
 205:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 206:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Check the arguments.
 207:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 208:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     ASSERT((ui32ChannelNum & 0xffff) < 32);
 209:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
 210:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 211:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // AND the specified channel bit with the enable register, and return the
 212:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // result.
 213:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 214:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
 215:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     return((HWREG(UDMA_ENASET) & (1 << (ui32ChannelNum & 0x1f))) ? true : false);
 287              		.loc 1 215 0
 288 00ac 094B     		ldr	r3, .L22
 289 00ae 1B68     		ldr	r3, [r3]
 290 00b0 7A68     		ldr	r2, [r7, #4]
 291 00b2 02F01F02 		and	r2, r2, #31
 292 00b6 0121     		movs	r1, #1
 293 00b8 01FA02F2 		lsl	r2, r1, r2
 294 00bc 1340     		ands	r3, r3, r2
 295 00be 002B     		cmp	r3, #0
 296 00c0 14BF     		ite	ne
 297 00c2 0123     		movne	r3, #1
 298 00c4 0023     		moveq	r3, #0
 299 00c6 DBB2     		uxtb	r3, r3
 216:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** }
 300              		.loc 1 216 0
 301 00c8 1846     		mov	r0, r3
 302 00ca 0C37     		adds	r7, r7, #12
 303              		.cfi_def_cfa_offset 4
 304 00cc BD46     		mov	sp, r7
 305              		.cfi_def_cfa_register 13
 306              		@ sp needed
 307 00ce 80BC     		pop	{r7}
 308              		.cfi_restore 7
 309              		.cfi_def_cfa_offset 0
 310 00d0 7047     		bx	lr
 311              	.L23:
 312 00d2 00BF     		.align	2
 313              	.L22:
 314 00d4 28F00F40 		.word	1074786344
 315              		.cfi_endproc
 316              	.LFE6:
 318              		.align	1
 319              		.global	uDMAControlBaseSet
 320              		.syntax unified
 321              		.thumb
 322              		.thumb_func
 323              		.fpu softvfp
 325              	uDMAControlBaseSet:
 326              	.LFB7:
 217:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
 218:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //*****************************************************************************
 219:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //
 220:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! Sets the base address for the channel control table
 221:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
 222:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \param pControlTable is a pointer to the 1024 byte aligned base address
 223:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! of the uDMA channel control table.
 224:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
 225:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! This function sets the base address of the channel control table.  This
 226:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! table resides in system memory and holds control information for each uDMA
 227:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! channel.  The table must be aligned on a 1024 byte boundary.  The base
 228:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! address must be set before any of the channel functions can be used.
 229:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
 230:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! The size of the channel control table depends on the number of uDMA
 231:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! channels, and which transfer modes are used.  Refer to the introductory
 232:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! text and the microcontroller datasheet for more information about the
 233:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! channel control table.
 234:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
 235:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \return None
 236:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //
 237:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //*****************************************************************************
 238:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** void
 239:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** uDMAControlBaseSet(void *pControlTable)
 240:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** {
 327              		.loc 1 240 0
 328              		.cfi_startproc
 329              		@ args = 0, pretend = 0, frame = 8
 330              		@ frame_needed = 1, uses_anonymous_args = 0
 331              		@ link register save eliminated.
 332 00d8 80B4     		push	{r7}
 333              		.cfi_def_cfa_offset 4
 334              		.cfi_offset 7, -4
 335 00da 83B0     		sub	sp, sp, #12
 336              		.cfi_def_cfa_offset 16
 337 00dc 00AF     		add	r7, sp, #0
 338              		.cfi_def_cfa_register 7
 339 00de 7860     		str	r0, [r7, #4]
 241:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 242:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Check the arguments.
 243:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 244:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     ASSERT(((uint32_t)pControlTable & ~0x3FF) ==
 245:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****            (uint32_t)pControlTable);
 246:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     ASSERT((uint32_t)pControlTable >= 0x20000000);
 247:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
 248:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 249:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Program the base address into the register.
 250:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 251:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     HWREG(UDMA_CTLBASE) = (uint32_t)pControlTable;
 340              		.loc 1 251 0
 341 00e0 034A     		ldr	r2, .L25
 342 00e2 7B68     		ldr	r3, [r7, #4]
 343 00e4 1360     		str	r3, [r2]
 252:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** }
 344              		.loc 1 252 0
 345 00e6 00BF     		nop
 346 00e8 0C37     		adds	r7, r7, #12
 347              		.cfi_def_cfa_offset 4
 348 00ea BD46     		mov	sp, r7
 349              		.cfi_def_cfa_register 13
 350              		@ sp needed
 351 00ec 80BC     		pop	{r7}
 352              		.cfi_restore 7
 353              		.cfi_def_cfa_offset 0
 354 00ee 7047     		bx	lr
 355              	.L26:
 356              		.align	2
 357              	.L25:
 358 00f0 08F00F40 		.word	1074786312
 359              		.cfi_endproc
 360              	.LFE7:
 362              		.align	1
 363              		.global	uDMAControlBaseGet
 364              		.syntax unified
 365              		.thumb
 366              		.thumb_func
 367              		.fpu softvfp
 369              	uDMAControlBaseGet:
 370              	.LFB8:
 253:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
 254:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //*****************************************************************************
 255:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //
 256:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! Gets the base address for the channel control table
 257:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
 258:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! This function gets the base address of the channel control table.  This
 259:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! table resides in system memory and holds control information for each uDMA
 260:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! channel.
 261:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
 262:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \return Returns a pointer to the base address of the channel control table.
 263:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //
 264:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //*****************************************************************************
 265:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** void *
 266:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** uDMAControlBaseGet(void)
 267:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** {
 371              		.loc 1 267 0
 372              		.cfi_startproc
 373              		@ args = 0, pretend = 0, frame = 0
 374              		@ frame_needed = 1, uses_anonymous_args = 0
 375              		@ link register save eliminated.
 376 00f4 80B4     		push	{r7}
 377              		.cfi_def_cfa_offset 4
 378              		.cfi_offset 7, -4
 379 00f6 00AF     		add	r7, sp, #0
 380              		.cfi_def_cfa_register 7
 268:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 269:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Read the current value of the control base register, and return it to
 270:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // the caller.
 271:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 272:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     return((void *)HWREG(UDMA_CTLBASE));
 381              		.loc 1 272 0
 382 00f8 024B     		ldr	r3, .L29
 383 00fa 1B68     		ldr	r3, [r3]
 273:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** }
 384              		.loc 1 273 0
 385 00fc 1846     		mov	r0, r3
 386 00fe BD46     		mov	sp, r7
 387              		.cfi_def_cfa_register 13
 388              		@ sp needed
 389 0100 80BC     		pop	{r7}
 390              		.cfi_restore 7
 391              		.cfi_def_cfa_offset 0
 392 0102 7047     		bx	lr
 393              	.L30:
 394              		.align	2
 395              	.L29:
 396 0104 08F00F40 		.word	1074786312
 397              		.cfi_endproc
 398              	.LFE8:
 400              		.align	1
 401              		.global	uDMAControlAlternateBaseGet
 402              		.syntax unified
 403              		.thumb
 404              		.thumb_func
 405              		.fpu softvfp
 407              	uDMAControlAlternateBaseGet:
 408              	.LFB9:
 274:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
 275:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //*****************************************************************************
 276:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //
 277:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! Gets the base address for the channel control table alternate structures
 278:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
 279:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! This function gets the base address of the second half of the channel
 280:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! control table that holds the alternate control structures for each channel.
 281:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
 282:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \return Returns a pointer to the base address of the second half of the
 283:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! channel control table.
 284:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //
 285:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //*****************************************************************************
 286:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** void *
 287:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** uDMAControlAlternateBaseGet(void)
 288:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** {
 409              		.loc 1 288 0
 410              		.cfi_startproc
 411              		@ args = 0, pretend = 0, frame = 0
 412              		@ frame_needed = 1, uses_anonymous_args = 0
 413              		@ link register save eliminated.
 414 0108 80B4     		push	{r7}
 415              		.cfi_def_cfa_offset 4
 416              		.cfi_offset 7, -4
 417 010a 00AF     		add	r7, sp, #0
 418              		.cfi_def_cfa_register 7
 289:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 290:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Read the current value of the control base register, and return it to
 291:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // the caller.
 292:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 293:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     return((void *)HWREG(UDMA_ALTBASE));
 419              		.loc 1 293 0
 420 010c 024B     		ldr	r3, .L33
 421 010e 1B68     		ldr	r3, [r3]
 294:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** }
 422              		.loc 1 294 0
 423 0110 1846     		mov	r0, r3
 424 0112 BD46     		mov	sp, r7
 425              		.cfi_def_cfa_register 13
 426              		@ sp needed
 427 0114 80BC     		pop	{r7}
 428              		.cfi_restore 7
 429              		.cfi_def_cfa_offset 0
 430 0116 7047     		bx	lr
 431              	.L34:
 432              		.align	2
 433              	.L33:
 434 0118 0CF00F40 		.word	1074786316
 435              		.cfi_endproc
 436              	.LFE9:
 438              		.align	1
 439              		.global	uDMAChannelRequest
 440              		.syntax unified
 441              		.thumb
 442              		.thumb_func
 443              		.fpu softvfp
 445              	uDMAChannelRequest:
 446              	.LFB10:
 295:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
 296:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //*****************************************************************************
 297:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //
 298:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! Requests a uDMA channel to start a transfer
 299:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
 300:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \param ui32ChannelNum is the channel number on which to request a uDMA
 301:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! transfer.
 302:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
 303:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! This function allows software to request a uDMA channel to begin a
 304:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! transfer.  This could be used for performing a memory to memory transfer,
 305:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! or if for some reason a transfer needs to be initiated by software instead
 306:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! of the peripheral associated with that channel.
 307:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
 308:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \note If the channel is \b UDMA_CH30_SW and interrupts
 309:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! are used, then the completion will be signaled on the uDMA dedicated
 310:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! interrupt.
 311:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! If a peripheral channel is used, then the completion will be signaled on the
 312:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! peripheral's interrupt.
 313:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
 314:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \return None
 315:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //
 316:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //*****************************************************************************
 317:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** void
 318:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** uDMAChannelRequest(uint32_t ui32ChannelNum)
 319:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** {
 447              		.loc 1 319 0
 448              		.cfi_startproc
 449              		@ args = 0, pretend = 0, frame = 8
 450              		@ frame_needed = 1, uses_anonymous_args = 0
 451              		@ link register save eliminated.
 452 011c 80B4     		push	{r7}
 453              		.cfi_def_cfa_offset 4
 454              		.cfi_offset 7, -4
 455 011e 83B0     		sub	sp, sp, #12
 456              		.cfi_def_cfa_offset 16
 457 0120 00AF     		add	r7, sp, #0
 458              		.cfi_def_cfa_register 7
 459 0122 7860     		str	r0, [r7, #4]
 320:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 321:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Check the arguments.
 322:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 323:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     ASSERT((ui32ChannelNum & 0xffff) < 32);
 324:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
 325:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 326:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Set the bit for this channel in the software uDMA request register.
 327:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 328:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     HWREG(UDMA_SWREQ) = 1 << (ui32ChannelNum & 0x1f);
 460              		.loc 1 328 0
 461 0124 7B68     		ldr	r3, [r7, #4]
 462 0126 03F01F03 		and	r3, r3, #31
 463 012a 0122     		movs	r2, #1
 464 012c 9A40     		lsls	r2, r2, r3
 465 012e 034B     		ldr	r3, .L36
 466 0130 1A60     		str	r2, [r3]
 329:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** }
 467              		.loc 1 329 0
 468 0132 00BF     		nop
 469 0134 0C37     		adds	r7, r7, #12
 470              		.cfi_def_cfa_offset 4
 471 0136 BD46     		mov	sp, r7
 472              		.cfi_def_cfa_register 13
 473              		@ sp needed
 474 0138 80BC     		pop	{r7}
 475              		.cfi_restore 7
 476              		.cfi_def_cfa_offset 0
 477 013a 7047     		bx	lr
 478              	.L37:
 479              		.align	2
 480              	.L36:
 481 013c 14F00F40 		.word	1074786324
 482              		.cfi_endproc
 483              	.LFE10:
 485              		.align	1
 486              		.global	uDMAChannelAttributeEnable
 487              		.syntax unified
 488              		.thumb
 489              		.thumb_func
 490              		.fpu softvfp
 492              	uDMAChannelAttributeEnable:
 493              	.LFB11:
 330:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
 331:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //*****************************************************************************
 332:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //
 333:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! Enables attributes of a uDMA channel
 334:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
 335:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \param ui32ChannelNum is the channel to configure.
 336:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \param ui32Attr is a combination of attributes for the channel.
 337:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
 338:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! This function is used to enable attributes of a uDMA channel.
 339:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
 340:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! The \e ui32Attr parameter is the logical OR of any of the following:
 341:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
 342:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! - \b UDMA_ATTR_USEBURST is used to restrict transfers to use only a burst
 343:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!   mode.
 344:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! - \b UDMA_ATTR_ALTSELECT is used to select the alternate control structure
 345:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!   for this channel (it is very unlikely that this flag should be used).
 346:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! - \b UDMA_ATTR_HIGH_PRIORITY is used to set this channel to high priority.
 347:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! - \b UDMA_ATTR_REQMASK is used to mask the hardware request signal from the
 348:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!   peripheral for this channel.
 349:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
 350:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \return None
 351:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //
 352:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //*****************************************************************************
 353:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** void
 354:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** uDMAChannelAttributeEnable(uint32_t ui32ChannelNum, uint32_t ui32Attr)
 355:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** {
 494              		.loc 1 355 0
 495              		.cfi_startproc
 496              		@ args = 0, pretend = 0, frame = 8
 497              		@ frame_needed = 1, uses_anonymous_args = 0
 498              		@ link register save eliminated.
 499 0140 80B4     		push	{r7}
 500              		.cfi_def_cfa_offset 4
 501              		.cfi_offset 7, -4
 502 0142 83B0     		sub	sp, sp, #12
 503              		.cfi_def_cfa_offset 16
 504 0144 00AF     		add	r7, sp, #0
 505              		.cfi_def_cfa_register 7
 506 0146 7860     		str	r0, [r7, #4]
 507 0148 3960     		str	r1, [r7]
 356:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 357:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Check the arguments.
 358:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 359:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     ASSERT((ui32ChannelNum & 0xffff) < 32);
 360:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     ASSERT((ui32Attr & ~(UDMA_ATTR_USEBURST | UDMA_ATTR_ALTSELECT |
 361:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****                          UDMA_ATTR_HIGH_PRIORITY | UDMA_ATTR_REQMASK)) == 0);
 362:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
 363:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 364:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // In case a channel selector macro (like UDMA_CH0_USB0EP1RX) was
 365:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // passed as the ui32ChannelNum parameter, extract just the channel number
 366:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // from this parameter.
 367:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 368:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     ui32ChannelNum &= 0x1f;
 508              		.loc 1 368 0
 509 014a 7B68     		ldr	r3, [r7, #4]
 510 014c 03F01F03 		and	r3, r3, #31
 511 0150 7B60     		str	r3, [r7, #4]
 369:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
 370:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 371:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Set the useburst bit for this channel if set in ui32Config.
 372:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 373:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     if(ui32Attr & UDMA_ATTR_USEBURST)
 512              		.loc 1 373 0
 513 0152 3B68     		ldr	r3, [r7]
 514 0154 03F00103 		and	r3, r3, #1
 515 0158 002B     		cmp	r3, #0
 516 015a 04D0     		beq	.L39
 374:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     {
 375:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****         HWREG(UDMA_USEBURSTSET) = 1 << ui32ChannelNum;
 517              		.loc 1 375 0
 518 015c 0122     		movs	r2, #1
 519 015e 7B68     		ldr	r3, [r7, #4]
 520 0160 9A40     		lsls	r2, r2, r3
 521 0162 124B     		ldr	r3, .L44
 522 0164 1A60     		str	r2, [r3]
 523              	.L39:
 376:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     }
 377:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
 378:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 379:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Set the alternate control select bit for this channel,
 380:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // if set in ui32Config.
 381:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 382:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     if(ui32Attr & UDMA_ATTR_ALTSELECT)
 524              		.loc 1 382 0
 525 0166 3B68     		ldr	r3, [r7]
 526 0168 03F00203 		and	r3, r3, #2
 527 016c 002B     		cmp	r3, #0
 528 016e 04D0     		beq	.L40
 383:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     {
 384:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****         HWREG(UDMA_ALTSET) = 1 << ui32ChannelNum;
 529              		.loc 1 384 0
 530 0170 0122     		movs	r2, #1
 531 0172 7B68     		ldr	r3, [r7, #4]
 532 0174 9A40     		lsls	r2, r2, r3
 533 0176 0E4B     		ldr	r3, .L44+4
 534 0178 1A60     		str	r2, [r3]
 535              	.L40:
 385:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     }
 386:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
 387:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 388:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Set the high priority bit for this channel, if set in ui32Config.
 389:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 390:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     if(ui32Attr & UDMA_ATTR_HIGH_PRIORITY)
 536              		.loc 1 390 0
 537 017a 3B68     		ldr	r3, [r7]
 538 017c 03F00403 		and	r3, r3, #4
 539 0180 002B     		cmp	r3, #0
 540 0182 04D0     		beq	.L41
 391:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     {
 392:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****         HWREG(UDMA_PRIOSET) = 1 << ui32ChannelNum;
 541              		.loc 1 392 0
 542 0184 0122     		movs	r2, #1
 543 0186 7B68     		ldr	r3, [r7, #4]
 544 0188 9A40     		lsls	r2, r2, r3
 545 018a 0A4B     		ldr	r3, .L44+8
 546 018c 1A60     		str	r2, [r3]
 547              	.L41:
 393:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     }
 394:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
 395:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 396:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Set the request mask bit for this channel, if set in ui32Config.
 397:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 398:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     if(ui32Attr & UDMA_ATTR_REQMASK)
 548              		.loc 1 398 0
 549 018e 3B68     		ldr	r3, [r7]
 550 0190 03F00803 		and	r3, r3, #8
 551 0194 002B     		cmp	r3, #0
 552 0196 04D0     		beq	.L43
 399:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     {
 400:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****         HWREG(UDMA_REQMASKSET) = 1 << ui32ChannelNum;
 553              		.loc 1 400 0
 554 0198 0122     		movs	r2, #1
 555 019a 7B68     		ldr	r3, [r7, #4]
 556 019c 9A40     		lsls	r2, r2, r3
 557 019e 064B     		ldr	r3, .L44+12
 558 01a0 1A60     		str	r2, [r3]
 559              	.L43:
 401:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     }
 402:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** }
 560              		.loc 1 402 0
 561 01a2 00BF     		nop
 562 01a4 0C37     		adds	r7, r7, #12
 563              		.cfi_def_cfa_offset 4
 564 01a6 BD46     		mov	sp, r7
 565              		.cfi_def_cfa_register 13
 566              		@ sp needed
 567 01a8 80BC     		pop	{r7}
 568              		.cfi_restore 7
 569              		.cfi_def_cfa_offset 0
 570 01aa 7047     		bx	lr
 571              	.L45:
 572              		.align	2
 573              	.L44:
 574 01ac 18F00F40 		.word	1074786328
 575 01b0 30F00F40 		.word	1074786352
 576 01b4 38F00F40 		.word	1074786360
 577 01b8 20F00F40 		.word	1074786336
 578              		.cfi_endproc
 579              	.LFE11:
 581              		.align	1
 582              		.global	uDMAChannelAttributeDisable
 583              		.syntax unified
 584              		.thumb
 585              		.thumb_func
 586              		.fpu softvfp
 588              	uDMAChannelAttributeDisable:
 589              	.LFB12:
 403:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
 404:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //*****************************************************************************
 405:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //
 406:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! Disables attributes of a uDMA channel
 407:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
 408:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \param ui32ChannelNum is the channel to configure.
 409:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \param ui32Attr is a combination of attributes for the channel.
 410:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
 411:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! This function is used to disable attributes of a uDMA channel.
 412:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
 413:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! The \e ui32Attr parameter is the logical OR of any of the following:
 414:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
 415:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! - \b UDMA_ATTR_USEBURST is used to restrict transfers to use only a burst
 416:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!   mode.
 417:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! - \b UDMA_ATTR_ALTSELECT is used to select the alternate control structure
 418:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!   for this channel.
 419:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! - \b UDMA_ATTR_HIGH_PRIORITY is used to set this channel to high priority.
 420:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! - \b UDMA_ATTR_REQMASK is used to mask the hardware request signal from the
 421:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!   peripheral for this channel.
 422:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
 423:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \return None
 424:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //
 425:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //*****************************************************************************
 426:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** void
 427:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** uDMAChannelAttributeDisable(uint32_t ui32ChannelNum, uint32_t ui32Attr)
 428:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** {
 590              		.loc 1 428 0
 591              		.cfi_startproc
 592              		@ args = 0, pretend = 0, frame = 8
 593              		@ frame_needed = 1, uses_anonymous_args = 0
 594              		@ link register save eliminated.
 595 01bc 80B4     		push	{r7}
 596              		.cfi_def_cfa_offset 4
 597              		.cfi_offset 7, -4
 598 01be 83B0     		sub	sp, sp, #12
 599              		.cfi_def_cfa_offset 16
 600 01c0 00AF     		add	r7, sp, #0
 601              		.cfi_def_cfa_register 7
 602 01c2 7860     		str	r0, [r7, #4]
 603 01c4 3960     		str	r1, [r7]
 429:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 430:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Check the arguments.
 431:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 432:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     ASSERT((ui32ChannelNum & 0xffff) < 32);
 433:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     ASSERT((ui32Attr & ~(UDMA_ATTR_USEBURST | UDMA_ATTR_ALTSELECT |
 434:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****                          UDMA_ATTR_HIGH_PRIORITY | UDMA_ATTR_REQMASK)) == 0);
 435:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
 436:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 437:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // In case a channel selector macro (like UDMA_CH0_USB0EP1RX) was
 438:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // passed as the ui32ChannelNum parameter, extract just the channel number
 439:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // from this parameter.
 440:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 441:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     ui32ChannelNum &= 0x1f;
 604              		.loc 1 441 0
 605 01c6 7B68     		ldr	r3, [r7, #4]
 606 01c8 03F01F03 		and	r3, r3, #31
 607 01cc 7B60     		str	r3, [r7, #4]
 442:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
 443:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 444:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Clear the useburst bit for this channel if set in ui32Config.
 445:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 446:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     if(ui32Attr & UDMA_ATTR_USEBURST)
 608              		.loc 1 446 0
 609 01ce 3B68     		ldr	r3, [r7]
 610 01d0 03F00103 		and	r3, r3, #1
 611 01d4 002B     		cmp	r3, #0
 612 01d6 04D0     		beq	.L47
 447:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     {
 448:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****         HWREG(UDMA_USEBURSTCLR) = 1 << ui32ChannelNum;
 613              		.loc 1 448 0
 614 01d8 0122     		movs	r2, #1
 615 01da 7B68     		ldr	r3, [r7, #4]
 616 01dc 9A40     		lsls	r2, r2, r3
 617 01de 124B     		ldr	r3, .L52
 618 01e0 1A60     		str	r2, [r3]
 619              	.L47:
 449:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     }
 450:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
 451:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 452:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Clear the alternate control select bit for this channel, if set in
 453:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // ui32Config.
 454:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 455:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     if(ui32Attr & UDMA_ATTR_ALTSELECT)
 620              		.loc 1 455 0
 621 01e2 3B68     		ldr	r3, [r7]
 622 01e4 03F00203 		and	r3, r3, #2
 623 01e8 002B     		cmp	r3, #0
 624 01ea 04D0     		beq	.L48
 456:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     {
 457:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****         HWREG(UDMA_ALTCLR) = 1 << ui32ChannelNum;
 625              		.loc 1 457 0
 626 01ec 0122     		movs	r2, #1
 627 01ee 7B68     		ldr	r3, [r7, #4]
 628 01f0 9A40     		lsls	r2, r2, r3
 629 01f2 0E4B     		ldr	r3, .L52+4
 630 01f4 1A60     		str	r2, [r3]
 631              	.L48:
 458:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     }
 459:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
 460:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 461:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Clear the high priority bit for this channel, if set in ui32Config.
 462:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 463:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     if(ui32Attr & UDMA_ATTR_HIGH_PRIORITY)
 632              		.loc 1 463 0
 633 01f6 3B68     		ldr	r3, [r7]
 634 01f8 03F00403 		and	r3, r3, #4
 635 01fc 002B     		cmp	r3, #0
 636 01fe 04D0     		beq	.L49
 464:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     {
 465:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****         HWREG(UDMA_PRIOCLR) = 1 << ui32ChannelNum;
 637              		.loc 1 465 0
 638 0200 0122     		movs	r2, #1
 639 0202 7B68     		ldr	r3, [r7, #4]
 640 0204 9A40     		lsls	r2, r2, r3
 641 0206 0A4B     		ldr	r3, .L52+8
 642 0208 1A60     		str	r2, [r3]
 643              	.L49:
 466:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     }
 467:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
 468:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 469:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Clear the request mask bit for this channel, if set in ui32Config.
 470:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 471:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     if(ui32Attr & UDMA_ATTR_REQMASK)
 644              		.loc 1 471 0
 645 020a 3B68     		ldr	r3, [r7]
 646 020c 03F00803 		and	r3, r3, #8
 647 0210 002B     		cmp	r3, #0
 648 0212 04D0     		beq	.L51
 472:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     {
 473:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****         HWREG(UDMA_REQMASKCLR) = 1 << ui32ChannelNum;
 649              		.loc 1 473 0
 650 0214 0122     		movs	r2, #1
 651 0216 7B68     		ldr	r3, [r7, #4]
 652 0218 9A40     		lsls	r2, r2, r3
 653 021a 064B     		ldr	r3, .L52+12
 654 021c 1A60     		str	r2, [r3]
 655              	.L51:
 474:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     }
 475:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** }
 656              		.loc 1 475 0
 657 021e 00BF     		nop
 658 0220 0C37     		adds	r7, r7, #12
 659              		.cfi_def_cfa_offset 4
 660 0222 BD46     		mov	sp, r7
 661              		.cfi_def_cfa_register 13
 662              		@ sp needed
 663 0224 80BC     		pop	{r7}
 664              		.cfi_restore 7
 665              		.cfi_def_cfa_offset 0
 666 0226 7047     		bx	lr
 667              	.L53:
 668              		.align	2
 669              	.L52:
 670 0228 1CF00F40 		.word	1074786332
 671 022c 34F00F40 		.word	1074786356
 672 0230 3CF00F40 		.word	1074786364
 673 0234 24F00F40 		.word	1074786340
 674              		.cfi_endproc
 675              	.LFE12:
 677              		.align	1
 678              		.global	uDMAChannelAttributeGet
 679              		.syntax unified
 680              		.thumb
 681              		.thumb_func
 682              		.fpu softvfp
 684              	uDMAChannelAttributeGet:
 685              	.LFB13:
 476:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
 477:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //*****************************************************************************
 478:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //
 479:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! Gets the enabled attributes of a uDMA channel
 480:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
 481:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \param ui32ChannelNum is the channel to configure.
 482:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
 483:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! This function returns a combination of flags representing the attributes of
 484:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! the uDMA channel.
 485:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
 486:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \return Returns the logical OR of the attributes of the uDMA channel, which
 487:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! can be any of the following:
 488:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! - \b UDMA_ATTR_USEBURST is used to restrict transfers to use only a burst
 489:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!   mode.
 490:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! - \b UDMA_ATTR_ALTSELECT is used to select the alternate control structure
 491:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!   for this channel.
 492:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! - \b UDMA_ATTR_HIGH_PRIORITY is used to set this channel to high priority.
 493:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! - \b UDMA_ATTR_REQMASK is used to mask the hardware request signal from the
 494:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!   peripheral for this channel.
 495:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //
 496:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //*****************************************************************************
 497:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** uint32_t
 498:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** uDMAChannelAttributeGet(uint32_t ui32ChannelNum)
 499:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** {
 686              		.loc 1 499 0
 687              		.cfi_startproc
 688              		@ args = 0, pretend = 0, frame = 16
 689              		@ frame_needed = 1, uses_anonymous_args = 0
 690              		@ link register save eliminated.
 691 0238 80B4     		push	{r7}
 692              		.cfi_def_cfa_offset 4
 693              		.cfi_offset 7, -4
 694 023a 85B0     		sub	sp, sp, #20
 695              		.cfi_def_cfa_offset 24
 696 023c 00AF     		add	r7, sp, #0
 697              		.cfi_def_cfa_register 7
 698 023e 7860     		str	r0, [r7, #4]
 500:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     uint32_t ui32Attr = 0;
 699              		.loc 1 500 0
 700 0240 0023     		movs	r3, #0
 701 0242 FB60     		str	r3, [r7, #12]
 501:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
 502:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 503:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Check the arguments.
 504:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 505:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     ASSERT((ui32ChannelNum & 0xffff) < 32);
 506:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
 507:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 508:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // In case a channel selector macro (like UDMA_CH0_USB0EP1RX) was
 509:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // passed as the ui32ChannelNum parameter, extract just the channel number
 510:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // from this parameter.
 511:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 512:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     ui32ChannelNum &= 0x1f;
 702              		.loc 1 512 0
 703 0244 7B68     		ldr	r3, [r7, #4]
 704 0246 03F01F03 		and	r3, r3, #31
 705 024a 7B60     		str	r3, [r7, #4]
 513:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
 514:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 515:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Check to see if useburst bit is set for this channel.
 516:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 517:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     if(HWREG(UDMA_USEBURSTSET) & (1 << ui32ChannelNum))
 706              		.loc 1 517 0
 707 024c 1C4B     		ldr	r3, .L60
 708 024e 1B68     		ldr	r3, [r3]
 709 0250 0121     		movs	r1, #1
 710 0252 7A68     		ldr	r2, [r7, #4]
 711 0254 01FA02F2 		lsl	r2, r1, r2
 712 0258 1340     		ands	r3, r3, r2
 713 025a 002B     		cmp	r3, #0
 714 025c 03D0     		beq	.L55
 518:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     {
 519:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****         ui32Attr |= UDMA_ATTR_USEBURST;
 715              		.loc 1 519 0
 716 025e FB68     		ldr	r3, [r7, #12]
 717 0260 43F00103 		orr	r3, r3, #1
 718 0264 FB60     		str	r3, [r7, #12]
 719              	.L55:
 520:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     }
 521:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
 522:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 523:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Check to see if the alternate control bit is set for this channel.
 524:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 525:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     if(HWREG(UDMA_ALTSET) & (1 << ui32ChannelNum))
 720              		.loc 1 525 0
 721 0266 174B     		ldr	r3, .L60+4
 722 0268 1B68     		ldr	r3, [r3]
 723 026a 0121     		movs	r1, #1
 724 026c 7A68     		ldr	r2, [r7, #4]
 725 026e 01FA02F2 		lsl	r2, r1, r2
 726 0272 1340     		ands	r3, r3, r2
 727 0274 002B     		cmp	r3, #0
 728 0276 03D0     		beq	.L56
 526:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     {
 527:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****         ui32Attr |= UDMA_ATTR_ALTSELECT;
 729              		.loc 1 527 0
 730 0278 FB68     		ldr	r3, [r7, #12]
 731 027a 43F00203 		orr	r3, r3, #2
 732 027e FB60     		str	r3, [r7, #12]
 733              	.L56:
 528:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     }
 529:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
 530:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 531:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Check to see if the high priority bit is set for this channel.
 532:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 533:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     if(HWREG(UDMA_PRIOSET) & (1 << ui32ChannelNum))
 734              		.loc 1 533 0
 735 0280 114B     		ldr	r3, .L60+8
 736 0282 1B68     		ldr	r3, [r3]
 737 0284 0121     		movs	r1, #1
 738 0286 7A68     		ldr	r2, [r7, #4]
 739 0288 01FA02F2 		lsl	r2, r1, r2
 740 028c 1340     		ands	r3, r3, r2
 741 028e 002B     		cmp	r3, #0
 742 0290 03D0     		beq	.L57
 534:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     {
 535:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****         ui32Attr |= UDMA_ATTR_HIGH_PRIORITY;
 743              		.loc 1 535 0
 744 0292 FB68     		ldr	r3, [r7, #12]
 745 0294 43F00403 		orr	r3, r3, #4
 746 0298 FB60     		str	r3, [r7, #12]
 747              	.L57:
 536:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     }
 537:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
 538:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 539:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Check to see if the request mask bit is set for this channel.
 540:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 541:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     if(HWREG(UDMA_REQMASKSET) & (1 << ui32ChannelNum))
 748              		.loc 1 541 0
 749 029a 0C4B     		ldr	r3, .L60+12
 750 029c 1B68     		ldr	r3, [r3]
 751 029e 0121     		movs	r1, #1
 752 02a0 7A68     		ldr	r2, [r7, #4]
 753 02a2 01FA02F2 		lsl	r2, r1, r2
 754 02a6 1340     		ands	r3, r3, r2
 755 02a8 002B     		cmp	r3, #0
 756 02aa 03D0     		beq	.L58
 542:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     {
 543:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****         ui32Attr |= UDMA_ATTR_REQMASK;
 757              		.loc 1 543 0
 758 02ac FB68     		ldr	r3, [r7, #12]
 759 02ae 43F00803 		orr	r3, r3, #8
 760 02b2 FB60     		str	r3, [r7, #12]
 761              	.L58:
 544:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     }
 545:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
 546:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 547:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Return the configuration flags.
 548:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 549:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     return(ui32Attr);
 762              		.loc 1 549 0
 763 02b4 FB68     		ldr	r3, [r7, #12]
 550:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** }
 764              		.loc 1 550 0
 765 02b6 1846     		mov	r0, r3
 766 02b8 1437     		adds	r7, r7, #20
 767              		.cfi_def_cfa_offset 4
 768 02ba BD46     		mov	sp, r7
 769              		.cfi_def_cfa_register 13
 770              		@ sp needed
 771 02bc 80BC     		pop	{r7}
 772              		.cfi_restore 7
 773              		.cfi_def_cfa_offset 0
 774 02be 7047     		bx	lr
 775              	.L61:
 776              		.align	2
 777              	.L60:
 778 02c0 18F00F40 		.word	1074786328
 779 02c4 30F00F40 		.word	1074786352
 780 02c8 38F00F40 		.word	1074786360
 781 02cc 20F00F40 		.word	1074786336
 782              		.cfi_endproc
 783              	.LFE13:
 785              		.align	1
 786              		.global	uDMAChannelControlSet
 787              		.syntax unified
 788              		.thumb
 789              		.thumb_func
 790              		.fpu softvfp
 792              	uDMAChannelControlSet:
 793              	.LFB14:
 551:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
 552:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //*****************************************************************************
 553:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //
 554:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! Sets the control parameters for a uDMA channel control structure
 555:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
 556:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \param ui32ChannelStructIndex is the logical OR of the uDMA channel number
 557:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! with \b UDMA_PRI_SELECT or \b UDMA_ALT_SELECT.
 558:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \param ui32Control is logical OR of several control values to set the control
 559:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! parameters for the channel.
 560:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
 561:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! This function is used to set control parameters for a uDMA transfer.  These
 562:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! are typically parameters that are not changed often.
 563:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
 564:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! The \e ui32ChannelStructIndex parameter should be the logical OR of the
 565:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! channel number with one of \b UDMA_PRI_SELECT or \b UDMA_ALT_SELECT to
 566:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! choose whether the primary or alternate data structure is used.
 567:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
 568:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! The \e ui32Control parameter is the logical OR of five values: the data size,
 569:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! the source address increment, the destination address increment, the
 570:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! arbitration size, and the use burst flag.  The choices available for each
 571:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! of these values is described below.
 572:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
 573:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! Choose the data size from one of \b UDMA_SIZE_8, \b UDMA_SIZE_16, or
 574:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \b UDMA_SIZE_32 to select a data size of 8, 16, or 32 bits.
 575:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
 576:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! Choose the source address increment from one of \b UDMA_SRC_INC_8,
 577:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \b UDMA_SRC_INC_16, \b UDMA_SRC_INC_32, or \b UDMA_SRC_INC_NONE to select
 578:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! an address increment of 8-bit bytes, 16-bit halfwords, 32-bit words, or
 579:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! to select non-incrementing.
 580:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
 581:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! Choose the destination address increment from one of \b UDMA_DST_INC_8,
 582:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \b UDMA_DST_INC_16, \b UDMA_DST_INC_32, or \b UDMA_DST_INC_NONE to select
 583:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! an address increment of 8-bit bytes, 16-bit halfwords, 32-bit words, or
 584:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! to select non-incrementing.
 585:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
 586:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! The arbitration size determines how many items are transferred before
 587:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! the uDMA controller re-arbitrates for the bus.  Choose the arbitration size
 588:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! from one of \b UDMA_ARB_1, \b UDMA_ARB_2, \b UDMA_ARB_4, \b UDMA_ARB_8,
 589:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! through \b UDMA_ARB_1024 to select the arbitration size from 1 to 1024
 590:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! items, in powers of 2.
 591:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
 592:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! The value \b UDMA_NEXT_USEBURST is used to force the channel to only
 593:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! respond to burst requests at the tail end of a scatter-gather transfer.
 594:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
 595:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \note The address increment cannot be smaller than the data size.
 596:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
 597:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \return None
 598:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //
 599:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //*****************************************************************************
 600:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** void
 601:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** uDMAChannelControlSet(uint32_t ui32ChannelStructIndex,
 602:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****                       uint32_t ui32Control)
 603:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** {
 794              		.loc 1 603 0
 795              		.cfi_startproc
 796              		@ args = 0, pretend = 0, frame = 16
 797              		@ frame_needed = 1, uses_anonymous_args = 0
 798              		@ link register save eliminated.
 799 02d0 80B4     		push	{r7}
 800              		.cfi_def_cfa_offset 4
 801              		.cfi_offset 7, -4
 802 02d2 85B0     		sub	sp, sp, #20
 803              		.cfi_def_cfa_offset 24
 804 02d4 00AF     		add	r7, sp, #0
 805              		.cfi_def_cfa_register 7
 806 02d6 7860     		str	r0, [r7, #4]
 807 02d8 3960     		str	r1, [r7]
 604:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     tDMAControlTable *pCtl;
 605:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
 606:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 607:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Check the arguments.
 608:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 609:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     ASSERT((ui32ChannelStructIndex & 0xffff) < 64);
 610:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     ASSERT(HWREG(UDMA_CTLBASE) != 0);
 611:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
 612:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 613:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // In case a channel selector macro (like UDMA_CH0_USB0EP1RX) was
 614:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // passed as the ui32ChannelStructIndex parameter, extract just the channel
 615:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // index from this parameter.
 616:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 617:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     ui32ChannelStructIndex &= 0x3f;
 808              		.loc 1 617 0
 809 02da 7B68     		ldr	r3, [r7, #4]
 810 02dc 03F03F03 		and	r3, r3, #63
 811 02e0 7B60     		str	r3, [r7, #4]
 618:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
 619:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 620:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Get the base address of the control table.
 621:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 622:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     pCtl = (tDMAControlTable *)HWREG(UDMA_CTLBASE);
 812              		.loc 1 622 0
 813 02e2 0B4B     		ldr	r3, .L63
 814 02e4 1B68     		ldr	r3, [r3]
 815 02e6 FB60     		str	r3, [r7, #12]
 623:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
 624:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 625:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Get the current control word value and mask off the fields to be
 626:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // changed, then OR in the new settings.
 627:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 628:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     pCtl[ui32ChannelStructIndex].ui32Control =
 629:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****         ((pCtl[ui32ChannelStructIndex].ui32Control &
 816              		.loc 1 629 0
 817 02e8 7B68     		ldr	r3, [r7, #4]
 818 02ea 1B01     		lsls	r3, r3, #4
 819 02ec FA68     		ldr	r2, [r7, #12]
 820 02ee 1344     		add	r3, r3, r2
 821 02f0 9A68     		ldr	r2, [r3, #8]
 822 02f2 084B     		ldr	r3, .L63+4
 823 02f4 1340     		ands	r3, r3, r2
 628:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****         ((pCtl[ui32ChannelStructIndex].ui32Control &
 824              		.loc 1 628 0
 825 02f6 7A68     		ldr	r2, [r7, #4]
 826 02f8 1201     		lsls	r2, r2, #4
 827 02fa F968     		ldr	r1, [r7, #12]
 828 02fc 0A44     		add	r2, r2, r1
 630:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****           ~(UDMACHCTL_CHCTL_DSTINC_M |
 631:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****             UDMACHCTL_CHCTL_DSTSIZE_M |
 632:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****             UDMACHCTL_CHCTL_SRCINC_M |
 633:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****             UDMACHCTL_CHCTL_SRCSIZE_M |
 634:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****             UDMACHCTL_CHCTL_ARBSIZE_M |
 635:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****             UDMACHCTL_CHCTL_NXTUSEBURST)) |
 829              		.loc 1 635 0
 830 02fe 3968     		ldr	r1, [r7]
 831 0300 0B43     		orrs	r3, r3, r1
 628:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****         ((pCtl[ui32ChannelStructIndex].ui32Control &
 832              		.loc 1 628 0
 833 0302 9360     		str	r3, [r2, #8]
 636:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****          ui32Control);
 637:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** }
 834              		.loc 1 637 0
 835 0304 00BF     		nop
 836 0306 1437     		adds	r7, r7, #20
 837              		.cfi_def_cfa_offset 4
 838 0308 BD46     		mov	sp, r7
 839              		.cfi_def_cfa_register 13
 840              		@ sp needed
 841 030a 80BC     		pop	{r7}
 842              		.cfi_restore 7
 843              		.cfi_def_cfa_offset 0
 844 030c 7047     		bx	lr
 845              	.L64:
 846 030e 00BF     		.align	2
 847              	.L63:
 848 0310 08F00F40 		.word	1074786312
 849 0314 F73FFC00 		.word	16531447
 850              		.cfi_endproc
 851              	.LFE14:
 853              		.align	1
 854              		.global	uDMAChannelTransferSet
 855              		.syntax unified
 856              		.thumb
 857              		.thumb_func
 858              		.fpu softvfp
 860              	uDMAChannelTransferSet:
 861              	.LFB15:
 638:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
 639:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //*****************************************************************************
 640:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //
 641:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! Sets the transfer parameters for a uDMA channel control structure
 642:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
 643:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \param ui32ChannelStructIndex is the logical OR of the uDMA channel number
 644:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! with either \b UDMA_PRI_SELECT or \b UDMA_ALT_SELECT.
 645:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \param ui32Mode is the type of uDMA transfer.
 646:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \param pvSrcAddr is the source address for the transfer.
 647:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \param pvDstAddr is the destination address for the transfer.
 648:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \param ui32TransferSize is the number of data items to transfer.
 649:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
 650:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! This function is used to set the parameters for a uDMA transfer.  These are
 651:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! typically parameters that are changed often.  The function
 652:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! uDMAChannelControlSet() MUST be called at least once for this channel prior
 653:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! to calling this function.
 654:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
 655:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! The \e ui32ChannelStructIndex parameter should be the logical OR of the
 656:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! channel number with one of \b UDMA_PRI_SELECT or \b UDMA_ALT_SELECT to
 657:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! choose whether the primary or alternate data structure is used.
 658:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
 659:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! The \e ui32Mode parameter should be one of the following values:
 660:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
 661:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! - \b UDMA_MODE_STOP stops the uDMA transfer.  The controller sets the mode
 662:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!   to this value at the end of a transfer.
 663:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! - \b UDMA_MODE_BASIC to perform a basic transfer based on request.
 664:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! - \b UDMA_MODE_AUTO to perform a transfer that will always complete once
 665:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!   started even if request is removed.
 666:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! - \b UDMA_MODE_PINGPONG to set up a transfer that switches between the
 667:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!   primary and alternate control structures for the channel.  This allows
 668:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!   use of ping-pong buffering for uDMA transfers.
 669:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! - \b UDMA_MODE_MEM_SCATTER_GATHER to set up a memory scatter-gather
 670:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!   transfer.
 671:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! - \b UDMA_MODE_PER_SCATTER_GATHER to set up a peripheral scatter-gather
 672:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!   transfer.
 673:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
 674:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! The \e pvSrcAddr and \e pvDstAddr parameters are pointers to the first
 675:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! location of the data to be transferred.  These addresses should be aligned
 676:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! according to the item size.  The compiler will take care of this if the
 677:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! pointers are pointing to storage of the appropriate data type.
 678:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
 679:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! The \e ui32TransferSize parameter is the number of data items, not the number
 680:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! of bytes.
 681:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
 682:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! The two scatter/gather modes, memory and peripheral, are actually different
 683:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! depending on whether the primary or alternate control structure is
 684:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! selected.  This function will look for the \b UDMA_PRI_SELECT and
 685:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \b UDMA_ALT_SELECT flag along with the channel number and will set the
 686:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! scatter/gather mode as appropriate for the primary or alternate control
 687:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! structure.
 688:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
 689:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! The channel must also be enabled using uDMAChannelEnable() after calling
 690:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! this function.  The transfer will not begin until the channel has been set
 691:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! up and enabled.  Note that the channel is automatically disabled after the
 692:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! transfer is completed, meaning that uDMAChannelEnable() must be called
 693:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! again after setting up the next transfer.
 694:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
 695:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \note Great care must be taken to not modify a channel control structure
 696:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! that is in use or else the results will be unpredictable, including the
 697:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! possibility of undesired data transfers to or from memory or peripherals.
 698:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! For BASIC and AUTO modes, it is safe to make changes when the channel is
 699:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! disabled, or the uDMAChannelModeGet() returns \b UDMA_MODE_STOP.  For
 700:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! PINGPONG or one of the SCATTER_GATHER modes, it is safe to modify the
 701:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! primary or alternate control structure only when the other is being used.
 702:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! The uDMAChannelModeGet() function will return \b UDMA_MODE_STOP when a
 703:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! channel control structure is inactive and safe to modify.
 704:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
 705:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \return None
 706:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //
 707:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //*****************************************************************************
 708:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** void
 709:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** uDMAChannelTransferSet(uint32_t ui32ChannelStructIndex,
 710:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****                        uint32_t ui32Mode, void *pvSrcAddr, void *pvDstAddr,
 711:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****                        uint32_t ui32TransferSize)
 712:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** {
 862              		.loc 1 712 0
 863              		.cfi_startproc
 864              		@ args = 4, pretend = 0, frame = 32
 865              		@ frame_needed = 1, uses_anonymous_args = 0
 866              		@ link register save eliminated.
 867 0318 80B4     		push	{r7}
 868              		.cfi_def_cfa_offset 4
 869              		.cfi_offset 7, -4
 870 031a 89B0     		sub	sp, sp, #36
 871              		.cfi_def_cfa_offset 40
 872 031c 00AF     		add	r7, sp, #0
 873              		.cfi_def_cfa_register 7
 874 031e F860     		str	r0, [r7, #12]
 875 0320 B960     		str	r1, [r7, #8]
 876 0322 7A60     		str	r2, [r7, #4]
 877 0324 3B60     		str	r3, [r7]
 713:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     tDMAControlTable *pControlTable;
 714:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     uint32_t ui32Control;
 715:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     uint32_t ui32Inc;
 716:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     uint32_t ui32BufferBytes;
 717:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
 718:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 719:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Check the arguments.
 720:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 721:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     ASSERT((ui32ChannelStructIndex & 0xffff) < 64);
 722:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     ASSERT(HWREG(UDMA_CTLBASE) != 0);
 723:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     ASSERT(ui32Mode <= UDMA_MODE_PER_SCATTER_GATHER);
 724:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     ASSERT((uint32_t)pvSrcAddr >= 0x20000000);
 725:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     ASSERT((uint32_t)pvDstAddr >= 0x20000000);
 726:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     ASSERT((ui32TransferSize != 0) && (ui32TransferSize <= 1024));
 727:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
 728:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 729:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // In case a channel selector macro (like UDMA_CH0_USB0EP1RX) was
 730:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // passed as the ui32ChannelStructIndex parameter, extract just the channel
 731:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // index from this parameter.
 732:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 733:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     ui32ChannelStructIndex &= 0x3f;
 878              		.loc 1 733 0
 879 0326 FB68     		ldr	r3, [r7, #12]
 880 0328 03F03F03 		and	r3, r3, #63
 881 032c FB60     		str	r3, [r7, #12]
 734:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
 735:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 736:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Get the base address of the control table.
 737:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 738:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     pControlTable = (tDMAControlTable *)HWREG(UDMA_CTLBASE);
 882              		.loc 1 738 0
 883 032e 3A4B     		ldr	r3, .L72
 884 0330 1B68     		ldr	r3, [r3]
 885 0332 FB61     		str	r3, [r7, #28]
 739:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
 740:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 741:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Get the current control word value and mask off the mode and size
 742:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // fields.
 743:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 744:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     ui32Control = (pControlTable[ui32ChannelStructIndex].ui32Control &
 886              		.loc 1 744 0
 887 0334 FB68     		ldr	r3, [r7, #12]
 888 0336 1B01     		lsls	r3, r3, #4
 889 0338 FA69     		ldr	r2, [r7, #28]
 890 033a 1344     		add	r3, r3, r2
 891 033c 9B68     		ldr	r3, [r3, #8]
 892 033e 23F47F53 		bic	r3, r3, #16320
 893 0342 23F03703 		bic	r3, r3, #55
 894 0346 BB61     		str	r3, [r7, #24]
 745:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****                    ~(UDMACHCTL_CHCTL_XFERSIZE_M | UDMACHCTL_CHCTL_XFERMODE_M));
 746:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
 747:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 748:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Adjust the mode if the alt control structure is selected.
 749:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 750:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     if(ui32ChannelStructIndex & UDMA_ALT_SELECT)
 895              		.loc 1 750 0
 896 0348 FB68     		ldr	r3, [r7, #12]
 897 034a 03F02003 		and	r3, r3, #32
 898 034e 002B     		cmp	r3, #0
 899 0350 09D0     		beq	.L66
 751:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     {
 752:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****         if((ui32Mode == UDMA_MODE_MEM_SCATTER_GATHER) ||
 900              		.loc 1 752 0
 901 0352 BB68     		ldr	r3, [r7, #8]
 902 0354 042B     		cmp	r3, #4
 903 0356 02D0     		beq	.L67
 904              		.loc 1 752 0 is_stmt 0 discriminator 1
 905 0358 BB68     		ldr	r3, [r7, #8]
 906 035a 062B     		cmp	r3, #6
 907 035c 03D1     		bne	.L66
 908              	.L67:
 753:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****                 (ui32Mode == UDMA_MODE_PER_SCATTER_GATHER))
 754:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****         {
 755:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****             ui32Mode |= UDMA_MODE_ALT_SELECT;
 909              		.loc 1 755 0 is_stmt 1
 910 035e BB68     		ldr	r3, [r7, #8]
 911 0360 43F00103 		orr	r3, r3, #1
 912 0364 BB60     		str	r3, [r7, #8]
 913              	.L66:
 756:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****         }
 757:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     }
 758:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
 759:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 760:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Set the transfer size and mode in the control word (but don't write the
 761:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // control word yet as it could kick off a transfer).
 762:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 763:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     ui32Control |= ui32Mode | ((ui32TransferSize - 1) << 4);
 914              		.loc 1 763 0
 915 0366 BB6A     		ldr	r3, [r7, #40]
 916 0368 013B     		subs	r3, r3, #1
 917 036a 1A01     		lsls	r2, r3, #4
 918 036c BB68     		ldr	r3, [r7, #8]
 919 036e 1343     		orrs	r3, r3, r2
 920 0370 BA69     		ldr	r2, [r7, #24]
 921 0372 1343     		orrs	r3, r3, r2
 922 0374 BB61     		str	r3, [r7, #24]
 764:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
 765:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 766:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Get the address increment value for the source, from the control word.
 767:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 768:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     ui32Inc = (ui32Control & UDMACHCTL_CHCTL_SRCINC_M);
 923              		.loc 1 768 0
 924 0376 BB69     		ldr	r3, [r7, #24]
 925 0378 03F04063 		and	r3, r3, #201326592
 926 037c 7B61     		str	r3, [r7, #20]
 769:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
 770:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 771:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Compute the ending source address of the transfer.  If the source
 772:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // increment is set to none, then the ending address is the same as the
 773:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // beginning.
 774:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 775:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     if(ui32Inc != UDMA_SRC_INC_NONE)
 927              		.loc 1 775 0
 928 037e 7B69     		ldr	r3, [r7, #20]
 929 0380 B3F1406F 		cmp	r3, #201326592
 930 0384 0CD0     		beq	.L68
 776:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     {
 777:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****         ui32Inc = ui32Inc >> 26;
 931              		.loc 1 777 0
 932 0386 7B69     		ldr	r3, [r7, #20]
 933 0388 9B0E     		lsrs	r3, r3, #26
 934 038a 7B61     		str	r3, [r7, #20]
 778:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****         ui32BufferBytes = ui32TransferSize << ui32Inc;
 935              		.loc 1 778 0
 936 038c BA6A     		ldr	r2, [r7, #40]
 937 038e 7B69     		ldr	r3, [r7, #20]
 938 0390 02FA03F3 		lsl	r3, r2, r3
 939 0394 3B61     		str	r3, [r7, #16]
 779:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****         pvSrcAddr = (void *)((uint32_t)pvSrcAddr + ui32BufferBytes - 1);
 940              		.loc 1 779 0
 941 0396 7A68     		ldr	r2, [r7, #4]
 942 0398 3B69     		ldr	r3, [r7, #16]
 943 039a 1344     		add	r3, r3, r2
 944 039c 013B     		subs	r3, r3, #1
 945 039e 7B60     		str	r3, [r7, #4]
 946              	.L68:
 780:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     }
 781:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
 782:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 783:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Load the source ending address into the control block.
 784:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 785:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     pControlTable[ui32ChannelStructIndex].pvSrcEndAddr = pvSrcAddr;
 947              		.loc 1 785 0
 948 03a0 FB68     		ldr	r3, [r7, #12]
 949 03a2 1B01     		lsls	r3, r3, #4
 950 03a4 FA69     		ldr	r2, [r7, #28]
 951 03a6 1344     		add	r3, r3, r2
 952 03a8 7A68     		ldr	r2, [r7, #4]
 953 03aa 1A60     		str	r2, [r3]
 786:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
 787:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 788:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Get the address increment value for the destination, from the control
 789:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // word.
 790:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 791:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     ui32Inc = ui32Control & UDMACHCTL_CHCTL_DSTINC_M;
 954              		.loc 1 791 0
 955 03ac BB69     		ldr	r3, [r7, #24]
 956 03ae 03F04043 		and	r3, r3, #-1073741824
 957 03b2 7B61     		str	r3, [r7, #20]
 792:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
 793:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 794:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Compute the ending destination address of the transfer.  If the
 795:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // destination increment is set to none, then the ending address is the
 796:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // same as the beginning.
 797:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 798:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     if(ui32Inc != UDMA_DST_INC_NONE)
 958              		.loc 1 798 0
 959 03b4 7B69     		ldr	r3, [r7, #20]
 960 03b6 B3F1404F 		cmp	r3, #-1073741824
 961 03ba 1BD0     		beq	.L69
 799:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     {
 800:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****         //
 801:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****         // There is a special case if this is setting up a scatter-gather
 802:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****         // transfer.  The destination pointer needs to point to the end of
 803:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****         // the alternate structure for this channel instead of calculating
 804:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****         // the end of the buffer in the normal way.
 805:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****         //
 806:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****         if((ui32Mode == UDMA_MODE_MEM_SCATTER_GATHER) ||
 962              		.loc 1 806 0
 963 03bc BB68     		ldr	r3, [r7, #8]
 964 03be 042B     		cmp	r3, #4
 965 03c0 02D0     		beq	.L70
 966              		.loc 1 806 0 is_stmt 0 discriminator 1
 967 03c2 BB68     		ldr	r3, [r7, #8]
 968 03c4 062B     		cmp	r3, #6
 969 03c6 08D1     		bne	.L71
 970              	.L70:
 807:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****                 (ui32Mode == UDMA_MODE_PER_SCATTER_GATHER))
 808:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****         {
 809:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****             pvDstAddr =
 810:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****                 (void *)&pControlTable[ui32ChannelStructIndex |
 971              		.loc 1 810 0 is_stmt 1
 972 03c8 FB68     		ldr	r3, [r7, #12]
 973 03ca 43F02003 		orr	r3, r3, #32
 974 03ce 1B01     		lsls	r3, r3, #4
 975 03d0 FA69     		ldr	r2, [r7, #28]
 976 03d2 1344     		add	r3, r3, r2
 809:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****                 (void *)&pControlTable[ui32ChannelStructIndex |
 977              		.loc 1 809 0
 978 03d4 0C33     		adds	r3, r3, #12
 979 03d6 3B60     		str	r3, [r7]
 980 03d8 0CE0     		b	.L69
 981              	.L71:
 811:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****                                        UDMA_ALT_SELECT].ui32Spare;
 812:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****         }
 813:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****         //
 814:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****         // Not a scatter-gather transfer, calculate end pointer normally.
 815:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****         //
 816:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****         else
 817:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****         {
 818:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****             ui32Inc = ui32Inc >> 30;
 982              		.loc 1 818 0
 983 03da 7B69     		ldr	r3, [r7, #20]
 984 03dc 9B0F     		lsrs	r3, r3, #30
 985 03de 7B61     		str	r3, [r7, #20]
 819:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****             ui32BufferBytes = ui32TransferSize << ui32Inc;
 986              		.loc 1 819 0
 987 03e0 BA6A     		ldr	r2, [r7, #40]
 988 03e2 7B69     		ldr	r3, [r7, #20]
 989 03e4 02FA03F3 		lsl	r3, r2, r3
 990 03e8 3B61     		str	r3, [r7, #16]
 820:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****             pvDstAddr = (void *)((uint32_t)pvDstAddr + ui32BufferBytes - 1);
 991              		.loc 1 820 0
 992 03ea 3A68     		ldr	r2, [r7]
 993 03ec 3B69     		ldr	r3, [r7, #16]
 994 03ee 1344     		add	r3, r3, r2
 995 03f0 013B     		subs	r3, r3, #1
 996 03f2 3B60     		str	r3, [r7]
 997              	.L69:
 821:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****         }
 822:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     }
 823:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
 824:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 825:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Load the destination ending address into the control block.
 826:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 827:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     pControlTable[ui32ChannelStructIndex].pvDstEndAddr = pvDstAddr;
 998              		.loc 1 827 0
 999 03f4 FB68     		ldr	r3, [r7, #12]
 1000 03f6 1B01     		lsls	r3, r3, #4
 1001 03f8 FA69     		ldr	r2, [r7, #28]
 1002 03fa 1344     		add	r3, r3, r2
 1003 03fc 3A68     		ldr	r2, [r7]
 1004 03fe 5A60     		str	r2, [r3, #4]
 828:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
 829:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 830:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Write the new control word value.
 831:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 832:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     pControlTable[ui32ChannelStructIndex].ui32Control = ui32Control;
 1005              		.loc 1 832 0
 1006 0400 FB68     		ldr	r3, [r7, #12]
 1007 0402 1B01     		lsls	r3, r3, #4
 1008 0404 FA69     		ldr	r2, [r7, #28]
 1009 0406 1344     		add	r3, r3, r2
 1010 0408 BA69     		ldr	r2, [r7, #24]
 1011 040a 9A60     		str	r2, [r3, #8]
 833:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** }
 1012              		.loc 1 833 0
 1013 040c 00BF     		nop
 1014 040e 2437     		adds	r7, r7, #36
 1015              		.cfi_def_cfa_offset 4
 1016 0410 BD46     		mov	sp, r7
 1017              		.cfi_def_cfa_register 13
 1018              		@ sp needed
 1019 0412 80BC     		pop	{r7}
 1020              		.cfi_restore 7
 1021              		.cfi_def_cfa_offset 0
 1022 0414 7047     		bx	lr
 1023              	.L73:
 1024 0416 00BF     		.align	2
 1025              	.L72:
 1026 0418 08F00F40 		.word	1074786312
 1027              		.cfi_endproc
 1028              	.LFE15:
 1030              		.align	1
 1031              		.global	uDMAChannelScatterGatherSet
 1032              		.syntax unified
 1033              		.thumb
 1034              		.thumb_func
 1035              		.fpu softvfp
 1037              	uDMAChannelScatterGatherSet:
 1038              	.LFB16:
 834:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
 835:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //*****************************************************************************
 836:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //
 837:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! Configures a uDMA channel for scatter-gather mode
 838:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
 839:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \param ui32ChannelNum is the uDMA channel number.
 840:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \param ui32TaskCount is the number of scatter-gather tasks to execute.
 841:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \param pvTaskList is a pointer to the beginning of the scatter-gather
 842:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! task list.
 843:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \param ui32IsPeriphSG is a flag to indicate it is a peripheral scatter-gather
 844:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! transfer (else it will be memory scatter-gather transfer)
 845:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
 846:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! This function is used to configure a channel for scatter-gather mode.
 847:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! The caller must have already set up a task list, and pass a pointer to
 848:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! the start of the task list as the \e pvTaskList parameter.  The
 849:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \e ui32TaskCount parameter is the count of tasks in the task list, not the
 850:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! size of the task list.  The flag \e bIsPeriphSG should be used to indicate
 851:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! if the scatter-gather should be configured for a peripheral or memory
 852:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! scatter-gather operation.
 853:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
 854:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \sa uDMATaskStructEntry
 855:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
 856:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \return None
 857:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //
 858:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //*****************************************************************************
 859:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** void
 860:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** uDMAChannelScatterGatherSet(uint32_t ui32ChannelNum,
 861:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****                             uint32_t ui32TaskCount, void *pvTaskList,
 862:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****                             uint32_t ui32IsPeriphSG)
 863:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** {
 1039              		.loc 1 863 0
 1040              		.cfi_startproc
 1041              		@ args = 0, pretend = 0, frame = 24
 1042              		@ frame_needed = 1, uses_anonymous_args = 0
 1043              		@ link register save eliminated.
 1044 041c 80B4     		push	{r7}
 1045              		.cfi_def_cfa_offset 4
 1046              		.cfi_offset 7, -4
 1047 041e 87B0     		sub	sp, sp, #28
 1048              		.cfi_def_cfa_offset 32
 1049 0420 00AF     		add	r7, sp, #0
 1050              		.cfi_def_cfa_register 7
 1051 0422 F860     		str	r0, [r7, #12]
 1052 0424 B960     		str	r1, [r7, #8]
 1053 0426 7A60     		str	r2, [r7, #4]
 1054 0428 3B60     		str	r3, [r7]
 864:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     tDMAControlTable *pControlTable;
 865:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     tDMAControlTable *pTaskTable;
 866:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
 867:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 868:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Check the parameters
 869:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 870:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     ASSERT((ui32ChannelNum & 0xffff) < 32);
 871:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     ASSERT(HWREG(UDMA_CTLBASE) != 0);
 872:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     ASSERT(pvTaskList != 0);
 873:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     ASSERT(ui32TaskCount <= 1024);
 874:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     ASSERT(ui32TaskCount != 0);
 875:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
 876:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 877:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // In case a channel selector macro (like UDMA_CH0_USB0EP1RX) was
 878:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // passed as the ui32ChannelNum parameter, extract just the channel number
 879:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // from this parameter.
 880:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 881:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     ui32ChannelNum &= 0x1f;
 1055              		.loc 1 881 0
 1056 042a FB68     		ldr	r3, [r7, #12]
 1057 042c 03F01F03 		and	r3, r3, #31
 1058 0430 FB60     		str	r3, [r7, #12]
 882:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
 883:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 884:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Get the base address of the control table.
 885:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 886:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     pControlTable = (tDMAControlTable *)HWREG(UDMA_CTLBASE);
 1059              		.loc 1 886 0
 1060 0432 1B4B     		ldr	r3, .L77
 1061 0434 1B68     		ldr	r3, [r3]
 1062 0436 7B61     		str	r3, [r7, #20]
 887:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
 888:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 889:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Get a handy pointer to the task list
 890:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 891:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     pTaskTable = (tDMAControlTable *)pvTaskList;
 1063              		.loc 1 891 0
 1064 0438 7B68     		ldr	r3, [r7, #4]
 1065 043a 3B61     		str	r3, [r7, #16]
 892:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
 893:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 894:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Compute the ending address for the source pointer.  This will be the
 895:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // last element of the last task in the task table
 896:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 897:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     pControlTable[ui32ChannelNum].pvSrcEndAddr =
 898:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****         &pTaskTable[ui32TaskCount - 1].ui32Spare;
 1066              		.loc 1 898 0
 1067 043c BB68     		ldr	r3, [r7, #8]
 1068 043e 03F18053 		add	r3, r3, #268435456
 1069 0442 013B     		subs	r3, r3, #1
 1070 0444 1B01     		lsls	r3, r3, #4
 1071 0446 3A69     		ldr	r2, [r7, #16]
 1072 0448 1A44     		add	r2, r2, r3
 897:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****         &pTaskTable[ui32TaskCount - 1].ui32Spare;
 1073              		.loc 1 897 0
 1074 044a FB68     		ldr	r3, [r7, #12]
 1075 044c 1B01     		lsls	r3, r3, #4
 1076 044e 7969     		ldr	r1, [r7, #20]
 1077 0450 0B44     		add	r3, r3, r1
 1078              		.loc 1 898 0
 1079 0452 0C32     		adds	r2, r2, #12
 897:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****         &pTaskTable[ui32TaskCount - 1].ui32Spare;
 1080              		.loc 1 897 0
 1081 0454 1A60     		str	r2, [r3]
 899:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
 900:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 901:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Compute the ending address for the destination pointer.  This will be
 902:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // the end of the alternate structure for this channel.
 903:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 904:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     pControlTable[ui32ChannelNum].pvDstEndAddr =
 905:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****         &pControlTable[ui32ChannelNum | UDMA_ALT_SELECT].ui32Spare;
 1082              		.loc 1 905 0
 1083 0456 FB68     		ldr	r3, [r7, #12]
 1084 0458 43F02003 		orr	r3, r3, #32
 1085 045c 1B01     		lsls	r3, r3, #4
 1086 045e 7A69     		ldr	r2, [r7, #20]
 1087 0460 1A44     		add	r2, r2, r3
 904:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****         &pControlTable[ui32ChannelNum | UDMA_ALT_SELECT].ui32Spare;
 1088              		.loc 1 904 0
 1089 0462 FB68     		ldr	r3, [r7, #12]
 1090 0464 1B01     		lsls	r3, r3, #4
 1091 0466 7969     		ldr	r1, [r7, #20]
 1092 0468 0B44     		add	r3, r3, r1
 1093              		.loc 1 905 0
 1094 046a 0C32     		adds	r2, r2, #12
 904:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****         &pControlTable[ui32ChannelNum | UDMA_ALT_SELECT].ui32Spare;
 1095              		.loc 1 904 0
 1096 046c 5A60     		str	r2, [r3, #4]
 906:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
 907:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 908:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Compute the control word.  Most configurable items are fixed for
 909:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // scatter-gather.  Item and increment sizes are all 32-bit and arb
 910:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // size must be 4.  The count is the number of items in the task list
 911:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // times 4 (4 words per task).
 912:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 913:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     pControlTable[ui32ChannelNum].ui32Control =
 914:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****         (UDMA_CHCTL_DSTINC_32 | UDMA_CHCTL_DSTSIZE_32 |
 915:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****          UDMA_CHCTL_SRCINC_32 | UDMA_CHCTL_SRCSIZE_32 |
 916:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****          UDMA_CHCTL_ARBSIZE_4 |
 917:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****          (((ui32TaskCount * 4) - 1) << UDMACHCTL_CHCTL_XFERSIZE_S) |
 1097              		.loc 1 917 0
 1098 046e BB68     		ldr	r3, [r7, #8]
 1099 0470 9B00     		lsls	r3, r3, #2
 1100 0472 013B     		subs	r3, r3, #1
 1101 0474 1B01     		lsls	r3, r3, #4
 918:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****          (ui32IsPeriphSG ? UDMA_CHCTL_XFERMODE_PER_SG :
 1102              		.loc 1 918 0
 1103 0476 3A68     		ldr	r2, [r7]
 1104 0478 002A     		cmp	r2, #0
 1105 047a 01D0     		beq	.L75
 1106              		.loc 1 918 0 is_stmt 0 discriminator 1
 1107 047c 0622     		movs	r2, #6
 1108 047e 00E0     		b	.L76
 1109              	.L75:
 1110              		.loc 1 918 0 discriminator 2
 1111 0480 0422     		movs	r2, #4
 1112              	.L76:
 917:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****          (ui32IsPeriphSG ? UDMA_CHCTL_XFERMODE_PER_SG :
 1113              		.loc 1 917 0 is_stmt 1
 1114 0482 1343     		orrs	r3, r3, r2
 913:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****         (UDMA_CHCTL_DSTINC_32 | UDMA_CHCTL_DSTSIZE_32 |
 1115              		.loc 1 913 0
 1116 0484 FA68     		ldr	r2, [r7, #12]
 1117 0486 1201     		lsls	r2, r2, #4
 1118 0488 7969     		ldr	r1, [r7, #20]
 1119 048a 0A44     		add	r2, r2, r1
 917:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****          (ui32IsPeriphSG ? UDMA_CHCTL_XFERMODE_PER_SG :
 1120              		.loc 1 917 0
 1121 048c 43F02A43 		orr	r3, r3, #-1442840576
 1122 0490 43F40043 		orr	r3, r3, #32768
 913:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****         (UDMA_CHCTL_DSTINC_32 | UDMA_CHCTL_DSTSIZE_32 |
 1123              		.loc 1 913 0
 1124 0494 9360     		str	r3, [r2, #8]
 919:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****           UDMA_CHCTL_XFERMODE_MEM_SG));
 920:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** }
 1125              		.loc 1 920 0
 1126 0496 00BF     		nop
 1127 0498 1C37     		adds	r7, r7, #28
 1128              		.cfi_def_cfa_offset 4
 1129 049a BD46     		mov	sp, r7
 1130              		.cfi_def_cfa_register 13
 1131              		@ sp needed
 1132 049c 80BC     		pop	{r7}
 1133              		.cfi_restore 7
 1134              		.cfi_def_cfa_offset 0
 1135 049e 7047     		bx	lr
 1136              	.L78:
 1137              		.align	2
 1138              	.L77:
 1139 04a0 08F00F40 		.word	1074786312
 1140              		.cfi_endproc
 1141              	.LFE16:
 1143              		.align	1
 1144              		.global	uDMAChannelSizeGet
 1145              		.syntax unified
 1146              		.thumb
 1147              		.thumb_func
 1148              		.fpu softvfp
 1150              	uDMAChannelSizeGet:
 1151              	.LFB17:
 921:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
 922:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //*****************************************************************************
 923:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //
 924:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! Gets the current transfer size for a uDMA channel control structure
 925:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
 926:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \param ui32ChannelStructIndex is the logical OR of the uDMA channel number
 927:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! with either \b UDMA_PRI_SELECT or \b UDMA_ALT_SELECT.
 928:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
 929:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! This function is used to get the uDMA transfer size for a channel.  The
 930:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! transfer size is the number of items to transfer, where the size of an item
 931:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! might be 8, 16, or 32 bits.  If a partial transfer has already occurred,
 932:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! then the number of remaining items will be returned.  If the transfer is
 933:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! complete, then 0 will be returned.
 934:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
 935:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \return Returns the number of items remaining to transfer.
 936:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //
 937:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //*****************************************************************************
 938:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** uint32_t
 939:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** uDMAChannelSizeGet(uint32_t ui32ChannelStructIndex)
 940:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** {
 1152              		.loc 1 940 0
 1153              		.cfi_startproc
 1154              		@ args = 0, pretend = 0, frame = 16
 1155              		@ frame_needed = 1, uses_anonymous_args = 0
 1156              		@ link register save eliminated.
 1157 04a4 80B4     		push	{r7}
 1158              		.cfi_def_cfa_offset 4
 1159              		.cfi_offset 7, -4
 1160 04a6 85B0     		sub	sp, sp, #20
 1161              		.cfi_def_cfa_offset 24
 1162 04a8 00AF     		add	r7, sp, #0
 1163              		.cfi_def_cfa_register 7
 1164 04aa 7860     		str	r0, [r7, #4]
 941:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     tDMAControlTable *pControlTable;
 942:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     uint32_t ui32Control;
 943:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
 944:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 945:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Check the arguments.
 946:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 947:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     ASSERT((ui32ChannelStructIndex & 0xffff) < 64);
 948:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     ASSERT(HWREG(UDMA_CTLBASE) != 0);
 949:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
 950:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 951:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // In case a channel selector macro (like UDMA_CH0_USB0EP1RX) was
 952:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // passed as the ui32ChannelStructIndex parameter, extract just the channel
 953:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // index from this parameter.
 954:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 955:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     ui32ChannelStructIndex &= 0x3f;
 1165              		.loc 1 955 0
 1166 04ac 7B68     		ldr	r3, [r7, #4]
 1167 04ae 03F03F03 		and	r3, r3, #63
 1168 04b2 7B60     		str	r3, [r7, #4]
 956:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
 957:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 958:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Get the base address of the control table.
 959:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 960:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     pControlTable = (tDMAControlTable *)HWREG(UDMA_CTLBASE);
 1169              		.loc 1 960 0
 1170 04b4 0C4B     		ldr	r3, .L82
 1171 04b6 1B68     		ldr	r3, [r3]
 1172 04b8 FB60     		str	r3, [r7, #12]
 961:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
 962:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 963:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Get the current control word value and mask off all but the size field
 964:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // and the mode field.
 965:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 966:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     ui32Control = (pControlTable[ui32ChannelStructIndex].ui32Control &
 1173              		.loc 1 966 0
 1174 04ba 7B68     		ldr	r3, [r7, #4]
 1175 04bc 1B01     		lsls	r3, r3, #4
 1176 04be FA68     		ldr	r2, [r7, #12]
 1177 04c0 1344     		add	r3, r3, r2
 1178 04c2 9A68     		ldr	r2, [r3, #8]
 1179 04c4 43F6F773 		movw	r3, #16375
 1180 04c8 1340     		ands	r3, r3, r2
 1181 04ca BB60     		str	r3, [r7, #8]
 967:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****                    (UDMACHCTL_CHCTL_XFERSIZE_M | UDMACHCTL_CHCTL_XFERMODE_M));
 968:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
 969:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 970:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // If the size field and mode field are 0 then the transfer is finished
 971:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // and there are no more items to transfer
 972:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 973:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     if(ui32Control == 0)
 1182              		.loc 1 973 0
 1183 04cc BB68     		ldr	r3, [r7, #8]
 1184 04ce 002B     		cmp	r3, #0
 1185 04d0 01D1     		bne	.L80
 974:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     {
 975:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****         return(0);
 1186              		.loc 1 975 0
 1187 04d2 0023     		movs	r3, #0
 1188 04d4 02E0     		b	.L81
 1189              	.L80:
 976:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     }
 977:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
 978:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 979:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Otherwise, if either the size field or more field is non-zero, then
 980:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // not all the items have been transferred.
 981:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
 982:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     else
 983:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     {
 984:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****         //
 985:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****         // Shift the size field and add one, then return to user.
 986:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****         //
 987:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****         return((ui32Control >> 4) + 1);
 1190              		.loc 1 987 0
 1191 04d6 BB68     		ldr	r3, [r7, #8]
 1192 04d8 1B09     		lsrs	r3, r3, #4
 1193 04da 0133     		adds	r3, r3, #1
 1194              	.L81:
 988:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     }
 989:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** }
 1195              		.loc 1 989 0
 1196 04dc 1846     		mov	r0, r3
 1197 04de 1437     		adds	r7, r7, #20
 1198              		.cfi_def_cfa_offset 4
 1199 04e0 BD46     		mov	sp, r7
 1200              		.cfi_def_cfa_register 13
 1201              		@ sp needed
 1202 04e2 80BC     		pop	{r7}
 1203              		.cfi_restore 7
 1204              		.cfi_def_cfa_offset 0
 1205 04e4 7047     		bx	lr
 1206              	.L83:
 1207 04e6 00BF     		.align	2
 1208              	.L82:
 1209 04e8 08F00F40 		.word	1074786312
 1210              		.cfi_endproc
 1211              	.LFE17:
 1213              		.align	1
 1214              		.global	uDMAChannelModeGet
 1215              		.syntax unified
 1216              		.thumb
 1217              		.thumb_func
 1218              		.fpu softvfp
 1220              	uDMAChannelModeGet:
 1221              	.LFB18:
 990:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
 991:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //*****************************************************************************
 992:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //
 993:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! Gets the transfer mode for a uDMA channel control structure
 994:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
 995:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \param ui32ChannelStructIndex is the logical OR of the uDMA channel number
 996:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! with either \b UDMA_PRI_SELECT or \b UDMA_ALT_SELECT.
 997:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
 998:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! This function is used to get the transfer mode for the uDMA channel.  It
 999:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! can be used to query the status of a transfer on a channel.  When the
1000:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! transfer is complete the mode will be \b UDMA_MODE_STOP.
1001:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
1002:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \return Returns the transfer mode of the specified channel and control
1003:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! structure, which will be one of the following values: \b UDMA_MODE_STOP,
1004:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \b UDMA_MODE_BASIC, \b UDMA_MODE_AUTO, \b UDMA_MODE_PINGPONG,
1005:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \b UDMA_MODE_MEM_SCATTER_GATHER, or \b UDMA_MODE_PER_SCATTER_GATHER.
1006:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //
1007:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //*****************************************************************************
1008:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** uint32_t
1009:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** uDMAChannelModeGet(uint32_t ui32ChannelStructIndex)
1010:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** {
 1222              		.loc 1 1010 0
 1223              		.cfi_startproc
 1224              		@ args = 0, pretend = 0, frame = 16
 1225              		@ frame_needed = 1, uses_anonymous_args = 0
 1226              		@ link register save eliminated.
 1227 04ec 80B4     		push	{r7}
 1228              		.cfi_def_cfa_offset 4
 1229              		.cfi_offset 7, -4
 1230 04ee 85B0     		sub	sp, sp, #20
 1231              		.cfi_def_cfa_offset 24
 1232 04f0 00AF     		add	r7, sp, #0
 1233              		.cfi_def_cfa_register 7
 1234 04f2 7860     		str	r0, [r7, #4]
1011:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     tDMAControlTable *pControlTable;
1012:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     uint32_t ui32Control;
1013:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
1014:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
1015:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Check the arguments.
1016:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
1017:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     ASSERT((ui32ChannelStructIndex & 0xffff) < 64);
1018:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     ASSERT(HWREG(UDMA_CTLBASE) != 0);
1019:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
1020:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
1021:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // In case a channel selector macro (like UDMA_CH0_USB0EP1RX) was
1022:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // passed as the ui32ChannelStructIndex parameter, extract just the channel
1023:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // index from this parameter.
1024:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
1025:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     ui32ChannelStructIndex &= 0x3f;
 1235              		.loc 1 1025 0
 1236 04f4 7B68     		ldr	r3, [r7, #4]
 1237 04f6 03F03F03 		and	r3, r3, #63
 1238 04fa 7B60     		str	r3, [r7, #4]
1026:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
1027:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
1028:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Get the base address of the control table.
1029:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
1030:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     pControlTable = (tDMAControlTable *)HWREG(UDMA_CTLBASE);
 1239              		.loc 1 1030 0
 1240 04fc 0F4B     		ldr	r3, .L88
 1241 04fe 1B68     		ldr	r3, [r3]
 1242 0500 BB60     		str	r3, [r7, #8]
1031:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
1032:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
1033:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Get the current control word value and mask off all but the mode field.
1034:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
1035:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     ui32Control = (pControlTable[ui32ChannelStructIndex].ui32Control &
 1243              		.loc 1 1035 0
 1244 0502 7B68     		ldr	r3, [r7, #4]
 1245 0504 1B01     		lsls	r3, r3, #4
 1246 0506 BA68     		ldr	r2, [r7, #8]
 1247 0508 1344     		add	r3, r3, r2
 1248 050a 9B68     		ldr	r3, [r3, #8]
 1249 050c 03F00703 		and	r3, r3, #7
 1250 0510 FB60     		str	r3, [r7, #12]
1036:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****                    UDMACHCTL_CHCTL_XFERMODE_M);
1037:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
1038:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
1039:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Check if scatter/gather mode, and if so, mask off the alt bit.
1040:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
1041:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     if(((ui32Control & ~UDMA_MODE_ALT_SELECT) == UDMA_MODE_MEM_SCATTER_GATHER) ||
 1251              		.loc 1 1041 0
 1252 0512 FB68     		ldr	r3, [r7, #12]
 1253 0514 23F00103 		bic	r3, r3, #1
 1254 0518 042B     		cmp	r3, #4
 1255 051a 04D0     		beq	.L85
1042:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****             ((ui32Control & ~UDMA_MODE_ALT_SELECT) == UDMA_MODE_PER_SCATTER_GATHER))
 1256              		.loc 1 1042 0 discriminator 1
 1257 051c FB68     		ldr	r3, [r7, #12]
 1258 051e 23F00103 		bic	r3, r3, #1
1041:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****             ((ui32Control & ~UDMA_MODE_ALT_SELECT) == UDMA_MODE_PER_SCATTER_GATHER))
 1259              		.loc 1 1041 0 discriminator 1
 1260 0522 062B     		cmp	r3, #6
 1261 0524 03D1     		bne	.L86
 1262              	.L85:
1043:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     {
1044:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****         ui32Control &= ~UDMA_MODE_ALT_SELECT;
 1263              		.loc 1 1044 0
 1264 0526 FB68     		ldr	r3, [r7, #12]
 1265 0528 23F00103 		bic	r3, r3, #1
 1266 052c FB60     		str	r3, [r7, #12]
 1267              	.L86:
1045:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     }
1046:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
1047:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
1048:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Return the mode to the caller.
1049:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
1050:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     return(ui32Control);
 1268              		.loc 1 1050 0
 1269 052e FB68     		ldr	r3, [r7, #12]
1051:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** }
 1270              		.loc 1 1051 0
 1271 0530 1846     		mov	r0, r3
 1272 0532 1437     		adds	r7, r7, #20
 1273              		.cfi_def_cfa_offset 4
 1274 0534 BD46     		mov	sp, r7
 1275              		.cfi_def_cfa_register 13
 1276              		@ sp needed
 1277 0536 80BC     		pop	{r7}
 1278              		.cfi_restore 7
 1279              		.cfi_def_cfa_offset 0
 1280 0538 7047     		bx	lr
 1281              	.L89:
 1282 053a 00BF     		.align	2
 1283              	.L88:
 1284 053c 08F00F40 		.word	1074786312
 1285              		.cfi_endproc
 1286              	.LFE18:
 1288              		.align	1
 1289              		.global	uDMAIntRegister
 1290              		.syntax unified
 1291              		.thumb
 1292              		.thumb_func
 1293              		.fpu softvfp
 1295              	uDMAIntRegister:
 1296              	.LFB19:
1052:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
1053:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
1054:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //*****************************************************************************
1055:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //
1056:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! Registers an interrupt handler for the uDMA controller
1057:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
1058:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \param ui32IntChannel identifies which uDMA interrupt is to be registered.
1059:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \param pfnHandler is a pointer to the function to be called when the
1060:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! interrupt is activated.
1061:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
1062:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! This sets and enables the handler to be called when the uDMA controller
1063:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! generates an interrupt.  The \e ui32IntChannel parameter should be one of the
1064:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! following:
1065:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
1066:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! - \b UDMA_INT_SW to register an interrupt handler to process interrupts
1067:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!   from the uDMA software channel (UDMA_CH30_SW)
1068:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! - \b UDMA_INT_ERR to register an interrupt handler to process uDMA error
1069:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!   interrupts
1070:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
1071:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \sa IntRegister() for important information about registering interrupt
1072:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! handlers.
1073:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
1074:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \note The interrupt handler for uDMA is for transfer completion when the
1075:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! channel UDMA_CH30W is used, and for error interrupts.  The
1076:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! interrupts for each peripheral channel are handled through the individual
1077:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! peripheral interrupt handlers.
1078:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
1079:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \return None
1080:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //
1081:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //*****************************************************************************
1082:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** void
1083:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** uDMAIntRegister(uint32_t ui32IntChannel, void (*pfnHandler)(void))
1084:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** {
 1297              		.loc 1 1084 0
 1298              		.cfi_startproc
 1299              		@ args = 0, pretend = 0, frame = 8
 1300              		@ frame_needed = 1, uses_anonymous_args = 0
 1301 0540 80B5     		push	{r7, lr}
 1302              		.cfi_def_cfa_offset 8
 1303              		.cfi_offset 7, -8
 1304              		.cfi_offset 14, -4
 1305 0542 82B0     		sub	sp, sp, #8
 1306              		.cfi_def_cfa_offset 16
 1307 0544 00AF     		add	r7, sp, #0
 1308              		.cfi_def_cfa_register 7
 1309 0546 7860     		str	r0, [r7, #4]
 1310 0548 3960     		str	r1, [r7]
1085:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
1086:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Check the arguments.
1087:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
1088:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     ASSERT(pfnHandler);
1089:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     ASSERT((ui32IntChannel == UDMA_INT_SW) || (ui32IntChannel == UDMA_INT_ERR));
1090:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
1091:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
1092:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Register the interrupt handler.
1093:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
1094:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     IntRegister(ui32IntChannel, pfnHandler);
 1311              		.loc 1 1094 0
 1312 054a 3968     		ldr	r1, [r7]
 1313 054c 7868     		ldr	r0, [r7, #4]
 1314 054e FFF7FEFF 		bl	IntRegister
1095:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
1096:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
1097:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Enable the memory management fault.
1098:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
1099:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     IntEnable(ui32IntChannel);
 1315              		.loc 1 1099 0
 1316 0552 7868     		ldr	r0, [r7, #4]
 1317 0554 FFF7FEFF 		bl	IntEnable
1100:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** }
 1318              		.loc 1 1100 0
 1319 0558 00BF     		nop
 1320 055a 0837     		adds	r7, r7, #8
 1321              		.cfi_def_cfa_offset 8
 1322 055c BD46     		mov	sp, r7
 1323              		.cfi_def_cfa_register 13
 1324              		@ sp needed
 1325 055e 80BD     		pop	{r7, pc}
 1326              		.cfi_endproc
 1327              	.LFE19:
 1329              		.align	1
 1330              		.global	uDMAIntUnregister
 1331              		.syntax unified
 1332              		.thumb
 1333              		.thumb_func
 1334              		.fpu softvfp
 1336              	uDMAIntUnregister:
 1337              	.LFB20:
1101:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
1102:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //*****************************************************************************
1103:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //
1104:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! Unregisters an interrupt handler for the uDMA controller
1105:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
1106:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \param ui32IntChannel identifies which uDMA interrupt to unregister.
1107:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
1108:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! This function will disable and clear the handler to be called for the
1109:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! specified uDMA interrupt.  The \e ui32IntChannel parameter should be one of
1110:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \b UDMA_INT_SW or \b UDMA_INT_ERR as documented for the function
1111:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! uDMAIntRegister().
1112:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
1113:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \sa IntRegister() for important information about registering interrupt
1114:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! handlers.
1115:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
1116:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \return None
1117:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //
1118:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //*****************************************************************************
1119:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** void
1120:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** uDMAIntUnregister(uint32_t ui32IntChannel)
1121:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** {
 1338              		.loc 1 1121 0
 1339              		.cfi_startproc
 1340              		@ args = 0, pretend = 0, frame = 8
 1341              		@ frame_needed = 1, uses_anonymous_args = 0
 1342 0560 80B5     		push	{r7, lr}
 1343              		.cfi_def_cfa_offset 8
 1344              		.cfi_offset 7, -8
 1345              		.cfi_offset 14, -4
 1346 0562 82B0     		sub	sp, sp, #8
 1347              		.cfi_def_cfa_offset 16
 1348 0564 00AF     		add	r7, sp, #0
 1349              		.cfi_def_cfa_register 7
 1350 0566 7860     		str	r0, [r7, #4]
1122:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
1123:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Disable the interrupt.
1124:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
1125:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     IntDisable(ui32IntChannel);
 1351              		.loc 1 1125 0
 1352 0568 7868     		ldr	r0, [r7, #4]
 1353 056a FFF7FEFF 		bl	IntDisable
1126:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
1127:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
1128:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Unregister the interrupt handler.
1129:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
1130:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     IntUnregister(ui32IntChannel);
 1354              		.loc 1 1130 0
 1355 056e 7868     		ldr	r0, [r7, #4]
 1356 0570 FFF7FEFF 		bl	IntUnregister
1131:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** }
 1357              		.loc 1 1131 0
 1358 0574 00BF     		nop
 1359 0576 0837     		adds	r7, r7, #8
 1360              		.cfi_def_cfa_offset 8
 1361 0578 BD46     		mov	sp, r7
 1362              		.cfi_def_cfa_register 13
 1363              		@ sp needed
 1364 057a 80BD     		pop	{r7, pc}
 1365              		.cfi_endproc
 1366              	.LFE20:
 1368              		.align	1
 1369              		.global	uDMAIntStatus
 1370              		.syntax unified
 1371              		.thumb
 1372              		.thumb_func
 1373              		.fpu softvfp
 1375              	uDMAIntStatus:
 1376              	.LFB21:
1132:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
1133:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //*****************************************************************************
1134:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //
1135:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! Gets the uDMA controller channel interrupt status
1136:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
1137:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! This function is used to get the interrupt status of the uDMA controller.
1138:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! The returned value is a 32-bit bit mask that indicates which channels are
1139:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! requesting an interrupt.  This function can be used from within an
1140:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! interrupt handler to determine or confirm which uDMA channel has requested
1141:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! an interrupt.
1142:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
1143:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \note This function is only available on devices that have the DMA Channel
1144:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! Interrupt Status Register (DMACHIS).  Please consult the data sheet for
1145:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! your part.
1146:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
1147:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \return Returns a 32-bit mask which indicates requesting uDMA channels.
1148:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! There is a bit for each channel, and a 1 in a bit indicates that channel
1149:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! is requesting an interrupt.  Multiple bits can be set.
1150:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //
1151:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //*****************************************************************************
1152:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** uint32_t
1153:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** uDMAIntStatus(void)
1154:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** {
 1377              		.loc 1 1154 0
 1378              		.cfi_startproc
 1379              		@ args = 0, pretend = 0, frame = 0
 1380              		@ frame_needed = 1, uses_anonymous_args = 0
 1381              		@ link register save eliminated.
 1382 057c 80B4     		push	{r7}
 1383              		.cfi_def_cfa_offset 4
 1384              		.cfi_offset 7, -4
 1385 057e 00AF     		add	r7, sp, #0
 1386              		.cfi_def_cfa_register 7
1155:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
1156:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Return the value of the uDMA interrupt status register
1157:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
1158:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     return(HWREG(UDMA_CHIS));
 1387              		.loc 1 1158 0
 1388 0580 024B     		ldr	r3, .L94
 1389 0582 1B68     		ldr	r3, [r3]
1159:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** }
 1390              		.loc 1 1159 0
 1391 0584 1846     		mov	r0, r3
 1392 0586 BD46     		mov	sp, r7
 1393              		.cfi_def_cfa_register 13
 1394              		@ sp needed
 1395 0588 80BC     		pop	{r7}
 1396              		.cfi_restore 7
 1397              		.cfi_def_cfa_offset 0
 1398 058a 7047     		bx	lr
 1399              	.L95:
 1400              		.align	2
 1401              	.L94:
 1402 058c 04F50F40 		.word	1074787588
 1403              		.cfi_endproc
 1404              	.LFE21:
 1406              		.align	1
 1407              		.global	uDMAIntClear
 1408              		.syntax unified
 1409              		.thumb
 1410              		.thumb_func
 1411              		.fpu softvfp
 1413              	uDMAIntClear:
 1414              	.LFB22:
1160:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
1161:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //*****************************************************************************
1162:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //
1163:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! Clears uDMA interrupt status
1164:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
1165:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \param ui32ChanMask is a 32-bit mask with one bit for each uDMA channel.
1166:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
1167:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! Clears bits in the uDMA interrupt status register according to which bits
1168:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! are set in \e ui32ChanMask. There is one bit for each channel. If a a bit
1169:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! is set in \e ui32ChanMask, then that corresponding channel's interrupt
1170:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! status will be cleared (if it was set).
1171:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
1172:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \note This function is only available on devices that have the DMA Channel
1173:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! Interrupt Status Register (DMACHIS).  Please consult the data sheet for
1174:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! your part.
1175:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
1176:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \return None
1177:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //
1178:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //*****************************************************************************
1179:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** void
1180:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** uDMAIntClear(uint32_t ui32ChanMask)
1181:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** {
 1415              		.loc 1 1181 0
 1416              		.cfi_startproc
 1417              		@ args = 0, pretend = 0, frame = 8
 1418              		@ frame_needed = 1, uses_anonymous_args = 0
 1419              		@ link register save eliminated.
 1420 0590 80B4     		push	{r7}
 1421              		.cfi_def_cfa_offset 4
 1422              		.cfi_offset 7, -4
 1423 0592 83B0     		sub	sp, sp, #12
 1424              		.cfi_def_cfa_offset 16
 1425 0594 00AF     		add	r7, sp, #0
 1426              		.cfi_def_cfa_register 7
 1427 0596 7860     		str	r0, [r7, #4]
1182:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
1183:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Clear the requested bits in the uDMA interrupt status register
1184:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
1185:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     HWREG(UDMA_CHIS) = ui32ChanMask;
 1428              		.loc 1 1185 0
 1429 0598 034A     		ldr	r2, .L97
 1430 059a 7B68     		ldr	r3, [r7, #4]
 1431 059c 1360     		str	r3, [r2]
1186:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** }
 1432              		.loc 1 1186 0
 1433 059e 00BF     		nop
 1434 05a0 0C37     		adds	r7, r7, #12
 1435              		.cfi_def_cfa_offset 4
 1436 05a2 BD46     		mov	sp, r7
 1437              		.cfi_def_cfa_register 13
 1438              		@ sp needed
 1439 05a4 80BC     		pop	{r7}
 1440              		.cfi_restore 7
 1441              		.cfi_def_cfa_offset 0
 1442 05a6 7047     		bx	lr
 1443              	.L98:
 1444              		.align	2
 1445              	.L97:
 1446 05a8 04F50F40 		.word	1074787588
 1447              		.cfi_endproc
 1448              	.LFE22:
 1450              		.align	1
 1451              		.global	uDMAChannelAssign
 1452              		.syntax unified
 1453              		.thumb
 1454              		.thumb_func
 1455              		.fpu softvfp
 1457              	uDMAChannelAssign:
 1458              	.LFB23:
1187:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
1188:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //*****************************************************************************
1189:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //
1190:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! Assigns a peripheral mapping for a uDMA channel
1191:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
1192:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \param ui32Mapping is a macro specifying the peripheral assignment for
1193:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! a channel
1194:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
1195:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! This function assigns a peripheral mapping to a uDMA channel.  It is
1196:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! used to select which peripheral is used for a uDMA channel.  The parameter
1197:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \e ui32Mapping should be one of the macros named \b UDMA_CHn_tttt from the
1198:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! header file \e udma.h.  For example, to assign uDMA channel 8 to the
1199:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! UART0RX channel, the parameter should be the macro \b UDMA_CH8_UART0RX.
1200:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
1201:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! Please consult the cc2538 data sheet for a table showing all the
1202:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! possible peripheral assignments for the uDMA channels for a particular
1203:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! device.
1204:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
1205:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \note This function is only available on devices that have the DMA Channel
1206:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! Map Select registers (DMACHMAP0-3).  Please consult the data sheet for
1207:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! your part.
1208:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //!
1209:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //! \return None
1210:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //
1211:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** //*****************************************************************************
1212:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** void
1213:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** uDMAChannelAssign(uint32_t ui32Mapping)
1214:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** {
 1459              		.loc 1 1214 0
 1460              		.cfi_startproc
 1461              		@ args = 0, pretend = 0, frame = 24
 1462              		@ frame_needed = 1, uses_anonymous_args = 0
 1463              		@ link register save eliminated.
 1464 05ac 80B4     		push	{r7}
 1465              		.cfi_def_cfa_offset 4
 1466              		.cfi_offset 7, -4
 1467 05ae 87B0     		sub	sp, sp, #28
 1468              		.cfi_def_cfa_offset 32
 1469 05b0 00AF     		add	r7, sp, #0
 1470              		.cfi_def_cfa_register 7
 1471 05b2 7860     		str	r0, [r7, #4]
1215:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     uint32_t ui32MapReg;
1216:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     uint32_t ui32MapShift;
1217:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     uint32_t ui32ChannelNum;
1218:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     uint32_t ui32Encoding;
1219:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
1220:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
1221:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Check the parameters
1222:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
1223:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     ASSERT((ui32Mapping & 0xffffff00) < 0x00050000);
1224:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
1225:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
1226:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Extract the channel number and map encoding value from the parameter.
1227:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
1228:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     ui32ChannelNum = ui32Mapping & 0xff;
 1472              		.loc 1 1228 0
 1473 05b4 7B68     		ldr	r3, [r7, #4]
 1474 05b6 DBB2     		uxtb	r3, r3
 1475 05b8 7B61     		str	r3, [r7, #20]
1229:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     ui32Encoding   = ui32Mapping >> 16;
 1476              		.loc 1 1229 0
 1477 05ba 7B68     		ldr	r3, [r7, #4]
 1478 05bc 1B0C     		lsrs	r3, r3, #16
 1479 05be 3B61     		str	r3, [r7, #16]
1230:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
1231:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
1232:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Find the uDMA channel mapping register and shift value to use for this
1233:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // channel
1234:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
1235:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     ui32MapReg = UDMA_CHMAP0 + ((ui32ChannelNum / 8) * 4);
 1480              		.loc 1 1235 0
 1481 05c0 7B69     		ldr	r3, [r7, #20]
 1482 05c2 DA08     		lsrs	r2, r3, #3
 1483 05c4 0E4B     		ldr	r3, .L100
 1484 05c6 1344     		add	r3, r3, r2
 1485 05c8 9B00     		lsls	r3, r3, #2
 1486 05ca FB60     		str	r3, [r7, #12]
1236:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     ui32MapShift = (ui32ChannelNum % 8) * 4;
 1487              		.loc 1 1236 0
 1488 05cc 7B69     		ldr	r3, [r7, #20]
 1489 05ce 03F00703 		and	r3, r3, #7
 1490 05d2 9B00     		lsls	r3, r3, #2
 1491 05d4 BB60     		str	r3, [r7, #8]
1237:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** 
1238:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
1239:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     // Set the channel map encoding for this channel
1240:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     //
1241:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****     HWREG(ui32MapReg) = (HWREG(ui32MapReg) & ~(0xf << ui32MapShift)) |
 1492              		.loc 1 1241 0
 1493 05d6 FB68     		ldr	r3, [r7, #12]
 1494 05d8 1B68     		ldr	r3, [r3]
 1495 05da 0F21     		movs	r1, #15
 1496 05dc BA68     		ldr	r2, [r7, #8]
 1497 05de 01FA02F2 		lsl	r2, r1, r2
 1498 05e2 D243     		mvns	r2, r2
 1499 05e4 03EA0201 		and	r1, r3, r2
1242:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****                         ui32Encoding << ui32MapShift;
 1500              		.loc 1 1242 0
 1501 05e8 3A69     		ldr	r2, [r7, #16]
 1502 05ea BB68     		ldr	r3, [r7, #8]
 1503 05ec 9A40     		lsls	r2, r2, r3
1241:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c ****                         ui32Encoding << ui32MapShift;
 1504              		.loc 1 1241 0
 1505 05ee FB68     		ldr	r3, [r7, #12]
 1506 05f0 0A43     		orrs	r2, r2, r1
 1507 05f2 1A60     		str	r2, [r3]
1243:build\openmote-cc2538_armgcc\bsp\boards\openmote-cc2538\source/udma.c **** }
 1508              		.loc 1 1243 0
 1509 05f4 00BF     		nop
 1510 05f6 1C37     		adds	r7, r7, #28
 1511              		.cfi_def_cfa_offset 4
 1512 05f8 BD46     		mov	sp, r7
 1513              		.cfi_def_cfa_register 13
 1514              		@ sp needed
 1515 05fa 80BC     		pop	{r7}
 1516              		.cfi_restore 7
 1517              		.cfi_def_cfa_offset 0
 1518 05fc 7047     		bx	lr
 1519              	.L101:
 1520 05fe 00BF     		.align	2
 1521              	.L100:
 1522 0600 44FD0310 		.word	268696900
 1523              		.cfi_endproc
 1524              	.LFE23:
 1526              	.Letext0:
 1527              		.file 2 "c:\\program files (x86)\\gnu tools arm embedded\\7 2018-q2-update\\arm-none-eabi\\include
 1528              		.file 3 "c:\\program files (x86)\\gnu tools arm embedded\\7 2018-q2-update\\arm-none-eabi\\include
 1529              		.file 4 "build\\openmote-cc2538_armgcc\\bsp\\boards\\openmote-cc2538\\source\\udma.h"
DEFINED SYMBOLS
                            *ABS*:00000000 udma.c
C:\Users\Lee\AppData\Local\Temp\ccSOttpr.s:15     .text:00000000 $t
C:\Users\Lee\AppData\Local\Temp\ccSOttpr.s:22     .text:00000000 uDMAEnable
C:\Users\Lee\AppData\Local\Temp\ccSOttpr.s:51     .text:00000014 $d
C:\Users\Lee\AppData\Local\Temp\ccSOttpr.s:55     .text:00000018 $t
C:\Users\Lee\AppData\Local\Temp\ccSOttpr.s:62     .text:00000018 uDMADisable
C:\Users\Lee\AppData\Local\Temp\ccSOttpr.s:90     .text:0000002c $d
C:\Users\Lee\AppData\Local\Temp\ccSOttpr.s:94     .text:00000030 $t
C:\Users\Lee\AppData\Local\Temp\ccSOttpr.s:101    .text:00000030 uDMAErrorStatusGet
C:\Users\Lee\AppData\Local\Temp\ccSOttpr.s:128    .text:00000040 $d
C:\Users\Lee\AppData\Local\Temp\ccSOttpr.s:132    .text:00000044 $t
C:\Users\Lee\AppData\Local\Temp\ccSOttpr.s:139    .text:00000044 uDMAErrorStatusClear
C:\Users\Lee\AppData\Local\Temp\ccSOttpr.s:167    .text:00000058 $d
C:\Users\Lee\AppData\Local\Temp\ccSOttpr.s:171    .text:0000005c $t
C:\Users\Lee\AppData\Local\Temp\ccSOttpr.s:178    .text:0000005c uDMAChannelEnable
C:\Users\Lee\AppData\Local\Temp\ccSOttpr.s:214    .text:0000007c $d
C:\Users\Lee\AppData\Local\Temp\ccSOttpr.s:218    .text:00000080 $t
C:\Users\Lee\AppData\Local\Temp\ccSOttpr.s:225    .text:00000080 uDMAChannelDisable
C:\Users\Lee\AppData\Local\Temp\ccSOttpr.s:261    .text:000000a0 $d
C:\Users\Lee\AppData\Local\Temp\ccSOttpr.s:265    .text:000000a4 $t
C:\Users\Lee\AppData\Local\Temp\ccSOttpr.s:272    .text:000000a4 uDMAChannelIsEnabled
C:\Users\Lee\AppData\Local\Temp\ccSOttpr.s:314    .text:000000d4 $d
C:\Users\Lee\AppData\Local\Temp\ccSOttpr.s:318    .text:000000d8 $t
C:\Users\Lee\AppData\Local\Temp\ccSOttpr.s:325    .text:000000d8 uDMAControlBaseSet
C:\Users\Lee\AppData\Local\Temp\ccSOttpr.s:358    .text:000000f0 $d
C:\Users\Lee\AppData\Local\Temp\ccSOttpr.s:362    .text:000000f4 $t
C:\Users\Lee\AppData\Local\Temp\ccSOttpr.s:369    .text:000000f4 uDMAControlBaseGet
C:\Users\Lee\AppData\Local\Temp\ccSOttpr.s:396    .text:00000104 $d
C:\Users\Lee\AppData\Local\Temp\ccSOttpr.s:400    .text:00000108 $t
C:\Users\Lee\AppData\Local\Temp\ccSOttpr.s:407    .text:00000108 uDMAControlAlternateBaseGet
C:\Users\Lee\AppData\Local\Temp\ccSOttpr.s:434    .text:00000118 $d
C:\Users\Lee\AppData\Local\Temp\ccSOttpr.s:438    .text:0000011c $t
C:\Users\Lee\AppData\Local\Temp\ccSOttpr.s:445    .text:0000011c uDMAChannelRequest
C:\Users\Lee\AppData\Local\Temp\ccSOttpr.s:481    .text:0000013c $d
C:\Users\Lee\AppData\Local\Temp\ccSOttpr.s:485    .text:00000140 $t
C:\Users\Lee\AppData\Local\Temp\ccSOttpr.s:492    .text:00000140 uDMAChannelAttributeEnable
C:\Users\Lee\AppData\Local\Temp\ccSOttpr.s:574    .text:000001ac $d
C:\Users\Lee\AppData\Local\Temp\ccSOttpr.s:581    .text:000001bc $t
C:\Users\Lee\AppData\Local\Temp\ccSOttpr.s:588    .text:000001bc uDMAChannelAttributeDisable
C:\Users\Lee\AppData\Local\Temp\ccSOttpr.s:670    .text:00000228 $d
C:\Users\Lee\AppData\Local\Temp\ccSOttpr.s:677    .text:00000238 $t
C:\Users\Lee\AppData\Local\Temp\ccSOttpr.s:684    .text:00000238 uDMAChannelAttributeGet
C:\Users\Lee\AppData\Local\Temp\ccSOttpr.s:778    .text:000002c0 $d
C:\Users\Lee\AppData\Local\Temp\ccSOttpr.s:785    .text:000002d0 $t
C:\Users\Lee\AppData\Local\Temp\ccSOttpr.s:792    .text:000002d0 uDMAChannelControlSet
C:\Users\Lee\AppData\Local\Temp\ccSOttpr.s:848    .text:00000310 $d
C:\Users\Lee\AppData\Local\Temp\ccSOttpr.s:853    .text:00000318 $t
C:\Users\Lee\AppData\Local\Temp\ccSOttpr.s:860    .text:00000318 uDMAChannelTransferSet
C:\Users\Lee\AppData\Local\Temp\ccSOttpr.s:1026   .text:00000418 $d
C:\Users\Lee\AppData\Local\Temp\ccSOttpr.s:1030   .text:0000041c $t
C:\Users\Lee\AppData\Local\Temp\ccSOttpr.s:1037   .text:0000041c uDMAChannelScatterGatherSet
C:\Users\Lee\AppData\Local\Temp\ccSOttpr.s:1139   .text:000004a0 $d
C:\Users\Lee\AppData\Local\Temp\ccSOttpr.s:1143   .text:000004a4 $t
C:\Users\Lee\AppData\Local\Temp\ccSOttpr.s:1150   .text:000004a4 uDMAChannelSizeGet
C:\Users\Lee\AppData\Local\Temp\ccSOttpr.s:1209   .text:000004e8 $d
C:\Users\Lee\AppData\Local\Temp\ccSOttpr.s:1213   .text:000004ec $t
C:\Users\Lee\AppData\Local\Temp\ccSOttpr.s:1220   .text:000004ec uDMAChannelModeGet
C:\Users\Lee\AppData\Local\Temp\ccSOttpr.s:1284   .text:0000053c $d
C:\Users\Lee\AppData\Local\Temp\ccSOttpr.s:1288   .text:00000540 $t
C:\Users\Lee\AppData\Local\Temp\ccSOttpr.s:1295   .text:00000540 uDMAIntRegister
C:\Users\Lee\AppData\Local\Temp\ccSOttpr.s:1336   .text:00000560 uDMAIntUnregister
C:\Users\Lee\AppData\Local\Temp\ccSOttpr.s:1375   .text:0000057c uDMAIntStatus
C:\Users\Lee\AppData\Local\Temp\ccSOttpr.s:1402   .text:0000058c $d
C:\Users\Lee\AppData\Local\Temp\ccSOttpr.s:1406   .text:00000590 $t
C:\Users\Lee\AppData\Local\Temp\ccSOttpr.s:1413   .text:00000590 uDMAIntClear
C:\Users\Lee\AppData\Local\Temp\ccSOttpr.s:1446   .text:000005a8 $d
C:\Users\Lee\AppData\Local\Temp\ccSOttpr.s:1450   .text:000005ac $t
C:\Users\Lee\AppData\Local\Temp\ccSOttpr.s:1457   .text:000005ac uDMAChannelAssign
C:\Users\Lee\AppData\Local\Temp\ccSOttpr.s:1522   .text:00000600 $d
                           .group:00000000 wm4.0.93d65e4ff05d5af51629690e5b534e57
                           .group:00000000 wm4.hw_sys_ctrl.h.39.50b4d7775c38e82076d0eb3bdc2daf82
                           .group:00000000 wm4.hw_udma.h.39.264bcf912c9ca2a6a4c20ac52cfd6e50
                           .group:00000000 wm4.hw_udmachctl.h.39.691b4def60389db06f6fa18129325381
                           .group:00000000 wm4._newlib_version.h.4.875b979a44719054cd750d0952ad3fd6
                           .group:00000000 wm4.features.h.33.318b64d71e0957639cfb30f1db1f7ec8
                           .group:00000000 wm4._default_types.h.15.247e5cd201eca3442cbf5404108c4935
                           .group:00000000 wm4._intsup.h.10.cce27fed8484c08a33f522034c30d2b5
                           .group:00000000 wm4._stdint.h.10.c24fa3af3bc1706662bb5593a907e841
                           .group:00000000 wm4.stdint.h.23.d53047a68f4a85177f80b422d52785ed
                           .group:00000000 wm4.stdbool.h.29.07dce69c3b78884144b7f7bd19483461
                           .group:00000000 wm4.hw_types.h.67.b10589a0806dcc2d274d6fab6b736519
                           .group:00000000 wm4.interrupt.h.41.272fc4ec0e276feb439e7974d0f77eaf
                           .group:00000000 wm4.udma.h.41.9638b4921f2086b7874ec413c0bf6e00

UNDEFINED SYMBOLS
IntRegister
IntEnable
IntDisable
IntUnregister
